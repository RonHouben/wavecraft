# {{plugin_name_title}}

A VST3/CLAP audio plugin built with the [Wavecraft SDK](https://github.com/RonHouben/wavecraft).

**Generated by:** `wavecraft create {{plugin_name}}`

---

## Quick Start

### Prerequisites

- **Rust** 1.75+ ([install](https://rustup.rs/))
- **Node.js** 18+ ([install](https://nodejs.org/))
- **macOS** (primary), Windows/Linux (secondary support)

### Build Your Plugin in 3 Steps

```bash
# 1. Install UI dependencies
cd ui && npm install && cd ..

# 2. Start development servers (Engine + UI hot reload)
cargo xtask dev
# Open http://localhost:5173 in your browser

# 3. Build plugin bundles when ready
cargo xtask bundle --release
```

The plugin bundles are created in `target/bundled/`:
- `{{plugin_name}}.vst3/` — VST3 format
- `{{plugin_name}}.clap` — CLAP format

### Install to System

```bash
cargo xtask install
```

This copies the bundles to your system plugin directories.

--- ## Project Structure

```
{{plugin_name}}/
├── Cargo.toml       # Workspace root
├── engine/          # Rust audio engine
│   ├── src/
│   │   └── lib.rs   # Plugin implementation (declarative DSL)
│   ├── xtask/       # Build automation (dev, bundle, install, etc.)
│   └── Cargo.toml   # Wavecraft SDK dependencies (git tags)
├── ui/              # React UI (TypeScript + Tailwind CSS)
│   ├── src/
│   │   ├── App.tsx
│   │   ├── components/  # Parameter controls, meters
│   │   └── lib/wavecraft-ipc/  # IPC client for Engine ↔ UI
│   ├── package.json
│   └── vite.config.ts
└── README.md
```

### Key Files

| File | Purpose |
|------|---------|
| `engine/src/lib.rs` | Plugin implementation using `wavecraft_plugin!` DSL |
| `ui/src/App.tsx` | User interface layout with parameter controls |
| `ui/src/lib/wavecraft-ipc/` | IPC client for real-time parameter sync |
| `engine/Cargo.toml` | Wavecraft SDK dependencies via git tags |

---

## Development Workflow

### Understanding the Declarative DSL

Your plugin is defined using Wavecraft's declarative macros in `engine/src/lib.rs`:

```rust
use wavecraft_core::prelude::*;

// Define processor chain (currently using built-in Gain processor)
wavecraft_processor!({{plugin_name_pascal}}Gain => Gain);

// Generate complete plugin with metadata
wavecraft_plugin! {
    name: "{{plugin_name_title}}",
    vendor: "{{vendor}}",
    url: "{{url}}",
    email: "{{email}}",
    signal: {{plugin_name_pascal}}Gain,
}
```

### Adding Custom DSP

To implement custom audio processing, replace the built-in `Gain` processor with your own:

```rust
use wavecraft_core::prelude::*;

// Custom processor struct
pub struct MyCustomProcessor {
    sample_rate: f32,
}

impl MyCustomProcessor {
    pub fn new() -> Self {
        Self { sample_rate: 44100.0 }
    }
}

// Implement the Processor trait
impl Processor for MyCustomProcessor {
    fn prepare(&mut self, sample_rate: f32, _max_block_size: usize) {
        self.sample_rate = sample_rate;
    }

    fn process(&mut self, _transport: &Transport, buffer: &mut Buffer) {
        // Your DSP code here (must be real-time safe!)
        for channel in buffer.iter_mut() {
            for sample in channel.iter_mut() {
                *sample *= 0.5; // Example: reduce volume by half
            }
        }
    }

    fn reset(&mut self) {
        // Called when playback stops - clear any state
    }
}

// Use your custom processor in the plugin
wavecraft_processor!(MyPluginProcessor => MyCustomProcessor);

wavecraft_plugin! {
    name: "{{plugin_name_title}}",
    vendor: "{{vendor}}",
    signal: MyPluginProcessor,
}
```

### Adding Parameters

Define custom parameters using the `#[derive(ProcessorParams)]` macro:

```rust
use wavecraft_core::prelude::*;

#[derive(ProcessorParams, Default)]
struct MyParams {
    #[param(range = "-60.0..=24.0", default = 0.0, unit = "dB")]
    gain: f32,
    
    #[param(range = "0.0..=1.0", default = 1.0, unit = "%")]
    mix: f32,
}

pub struct MyProcessor {
    params: MyParams,
}

impl Processor for MyProcessor {
    fn process(&mut self, _transport: &Transport, buffer: &mut Buffer) {
        let gain_db = self.params.gain;
        let gain_linear = db_to_linear(gain_db);
        
        for channel in buffer.iter_mut() {
            for sample in channel.iter_mut() {
                *sample *= gain_linear;
            }
        }
    }
}
```

Then update the UI to control your parameters:

```tsx
// In ui/src/App.tsx
<ParameterSlider id="gain" />
<ParameterSlider id="mix" />
```

### Real-Time Safety Rules

⚠️ **Critical:** Code in `process()` runs on the audio thread and must follow strict rules:

**Never do:**
- ❌ Allocate memory (`Vec::push`, `String::from`, `Box::new`)
- ❌ Lock mutexes or use blocking operations
- ❌ Make system calls (file I/O, network, logging)
- ❌ Use `println!` or any I/O

**Always do:**
- ✅ Use pre-allocated buffers
- ✅ Use atomic types for shared state
- ✅ Keep operations deterministic and fast
- ✅ Use `#[inline]` for hot-path functions

### Development Commands

```bash
# Start dev servers (Engine WebSocket + UI with hot reload + Auto audio if configured)
cargo xtask dev

# Build debug plugin (fast compilation)
cargo xtask bundle

# Build release plugin (optimized)
cargo xtask bundle --release

# Install to system directories
cargo xtask install

# Run linters
cargo xtask lint

# Run tests
cargo xtask test

# Clean build artifacts
cargo xtask clean
```

### Audio Testing with Real Input

`cargo xtask dev` automatically enables real-time audio input testing when available:

**What happens:**
- If your project has `dev-audio` binary configured, it compiles and starts automatically
- Audio flows from your system microphone through your DSP code
- Meters update in real-time with actual audio levels
- Parameter changes apply instantly to the audio stream
- UI hot-reloading works while audio is running

**Audio binary setup (included in new projects):**
The template includes `engine/src/bin/dev-audio.rs` and the necessary configuration in `engine/Cargo.toml`:
```toml
[[bin]]
name = "dev-audio"
path = "src/bin/dev-audio.rs"
```

**Note:** If the audio binary fails to compile or you're working on a machine without audio hardware, the dev server continues with browser-only mode. You'll see helpful messages about enabling audio if it's not configured.

---

## Plugin Configuration

All plugin metadata is configured in the `wavecraft_plugin!` macro in `engine/src/lib.rs`:

```rust
wavecraft_plugin! {
    name: "{{plugin_name_title}}",    // Display name in DAW
    vendor: "{{vendor}}",              // Your company/name
    url: "{{url}}",                    // Website (optional)
    email: "{{email}}",                // Contact email (optional)
    signal: {{plugin_name_pascal}}Gain,  // Processor chain entry point
}
```

### Unique Plugin IDs

**Important:** The template generates default IDs, but you should customize them before distribution:

**CLAP ID:** In `engine/Cargo.toml`:
```toml
[package.metadata.clap]
id = "com.{{vendor}}.{{plugin_name}}"  # Change to your domain
```

**VST3 Class ID:** Auto-generated from plugin name, but can be customized in `wavecraft_plugin!`:
```rust
wavecraft_plugin! {
    // ... other fields
    vst3_class_id: *b"YourUniqueID0000",  // Optional: 16-byte unique ID
}
```

---

## Wavecraft SDK Overview

Your plugin depends on Wavecraft SDK crates via git tags (until crates.io publishing):

```toml
# engine/Cargo.toml
[dependencies]
wavecraft-core = { git = "https://github.com/RonHouben/wavecraft", tag = "{{sdk_version}}" }
wavecraft-protocol = { git = "https://github.com/RonHouben/wavecraft", tag = "{{sdk_version}}" }
# ...
```

| Crate | Purpose |
|-------|---------|
| `wavecraft-core` | Main framework, nih-plug integration, declarative DSL, editor |
| `wavecraft-protocol` | Parameter definitions, IPC contracts |
| `wavecraft-dsp` | DSP traits (`Processor`), utilities, built-in processors |
| `wavecraft-bridge` | IPC handler (UI ↔ Audio communication) |
| `wavecraft-metering` | Real-time safe metering with SPSC ring buffers |

### Core Traits

**`Processor` trait** — Implement this for custom DSP:
```rust
pub trait Processor {
    fn prepare(&mut self, sample_rate: f32, max_block_size: usize);
    fn process(&mut self, transport: &Transport, buffer: &mut Buffer);
    fn reset(&mut self);
}
```

**`ProcessorParams` derive** — Auto-generate parameter structs:
```rust
#[derive(ProcessorParams, Default)]
struct MyParams {
    #[param(range = "0.0..=1.0", default = 0.5)]
    level: f32,
}
```

---

## Building for Distribution

### Build Release Bundles

```bash
cargo xtask bundle --release
```

This creates optimized plugin bundles in `target/bundled/`:
- `{{plugin_name}}.vst3/` — VST3 format
- `{{plugin_name}}.clap` — CLAP format

### Installation Locations

| Platform | VST3 | CLAP |
|----------|------|------|
| macOS | `~/Library/Audio/Plug-Ins/VST3/` | `~/Library/Audio/Plug-Ins/CLAP/` |
| Windows | `C:\Program Files\Common Files\VST3\` | `C:\Program Files\Common Files\CLAP\` |
| Linux | `~/.vst3/` | `~/.clap/` |

### Quick Install

```bash
cargo xtask install
```

This copies bundles to your system plugin directories.

---

## Troubleshooting

### Plugin doesn't show up in DAW

1. Verify bundles exist: `ls target/bundled/`
2. Check installation: `ls ~/Library/Audio/Plug-Ins/VST3/`
3. Rescan plugins in your DAW preferences
4. Check DAW logs for loading errors

### UI doesn't load or appears blank

1. Rebuild UI: `cd ui && npm run build && cd ..`
2. Verify `ui/dist/` has files: `ls ui/dist/`
3. Rebuild plugin: `cargo xtask bundle`

### Build errors

1. Update Rust: `rustup update stable`
2. Clean build: `cargo clean`
3. Verify prerequisites:
   - `rustc --version` (need 1.75+)
   - `node --version` (need 18+)

### Dev mode not connecting

1. Check WebSocket server is running: `lsof -i :9001`
2. Verify UI dev server is running: `lsof -i :5173`
3. Check browser console for connection errors
4. Restart: Stop servers and run `cargo xtask dev` again

---

## Next Steps

- **[Wavecraft SDK Documentation](https://github.com/RonHouben/wavecraft)** — Full SDK reference
- **[Getting Started Guide](https://github.com/RonHouben/wavecraft/blob/main/docs/guides/sdk-getting-started.md)** — Comprehensive tutorial
- **[Coding Standards](https://github.com/RonHouben/wavecraft/blob/main/docs/architecture/coding-standards.md)** — Best practices
- **[High-Level Design](https://github.com/RonHouben/wavecraft/blob/main/docs/architecture/high-level-design.md)** — Architecture overview

## Support

- **Issues:** [GitHub Issues](https://github.com/RonHouben/wavecraft/issues)
- **Discussions:** [GitHub Discussions](https://github.com/RonHouben/wavecraft/discussions)

---

## License

MIT OR Apache-2.0 (choose based on your preference)

---

**Built with [Wavecraft](https://github.com/RonHouben/wavecraft)** — Modern audio plugin framework for Rust + React
