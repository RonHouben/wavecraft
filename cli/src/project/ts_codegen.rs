//! TypeScript code generation utilities.
//!
//! Generates `ui/src/generated/parameters.ts` with module augmentation for
//! `@wavecraft/core` so parameter IDs are available as IDE autocomplete.

use std::collections::BTreeMap;
use std::fs;
use std::path::Path;

use anyhow::{Context, Result};
use wavecraft_protocol::{ParameterInfo, ParameterType, ProcessorInfo};

const PARAMETER_ID_MAP_AUGMENTED_MARKER: &str = "__wavecraft_internal_augmented__";
const PROCESSOR_ID_MAP_AUGMENTED_MARKER: &str = "__wavecraft_internal_processors_augmented__";

fn ts_string_literal(value: &str) -> Result<String> {
    let mut escaped = String::new();
    for ch in value.chars() {
        match ch {
            '\\' => escaped.push_str("\\\\"),
            '\'' => escaped.push_str("\\'"),
            '\n' => escaped.push_str("\\n"),
            '\r' => escaped.push_str("\\r"),
            '\t' => escaped.push_str("\\t"),
            '\u{08}' => escaped.push_str("\\b"),
            '\u{0C}' => escaped.push_str("\\f"),
            c if c.is_control() => {
                use std::fmt::Write as _;
                write!(&mut escaped, "\\u{:04x}", c as u32)
                    .context("Failed to escape TypeScript string literal")?;
            }
            c => escaped.push(c),
        }
    }

    Ok(format!("'{}'", escaped))
}

fn is_ascii_typescript_identifier(value: &str) -> bool {
    let mut chars = value.chars();

    let Some(first) = chars.next() else {
        return false;
    };

    if !(first.is_ascii_alphabetic() || first == '_' || first == '$') {
        return false;
    }

    chars.all(|ch| ch.is_ascii_alphanumeric() || ch == '_' || ch == '$')
}

fn ts_interface_property_key(value: &str) -> Result<String> {
    if is_ascii_typescript_identifier(value) {
        Ok(value.to_string())
    } else {
        ts_string_literal(value)
    }
}

fn ts_value_type_for_param(param_type: ParameterType) -> &'static str {
    match param_type {
        ParameterType::Bool => "boolean",
        ParameterType::Float | ParameterType::Enum => "number",
    }
}

/// Generate TypeScript parameter ID augmentation file.
///
/// Output path: `{ui_dir}/src/generated/parameters.ts`
///
/// The file augments `@wavecraft/core`'s `ParameterIdMap` interface so
/// `ParameterId` resolves to a typed union of parameter IDs in the user's
/// project TypeScript compilation.
pub fn write_parameter_types(ui_dir: &Path, params: &[ParameterInfo]) -> Result<()> {
    let generated_dir = ui_dir.join("src").join("generated");
    fs::create_dir_all(&generated_dir).with_context(|| {
        format!(
            "Failed to create generated TypeScript directory: {}",
            generated_dir.display()
        )
    })?;

    let mut content = String::new();
    content.push_str("/**\n");
    content.push_str(" * Auto-generated by `wavecraft start` — DO NOT EDIT\n");
    content.push_str(" *\n");
    content.push_str(" * Type-safe parameter IDs for your plugin.\n");
    content.push_str(" * Regenerated automatically when Rust source files change.\n");
    content.push_str(" */\n\n");

    content.push_str("declare module '@wavecraft/core' {\n");
    content.push_str("  interface ParameterIdMap {\n");
    content.push_str("    ");
    content.push_str(PARAMETER_ID_MAP_AUGMENTED_MARKER);
    content.push_str(": true;\n");

    let mut typed_ids: BTreeMap<&str, &str> = BTreeMap::new();
    for param in params {
        let value_type = ts_value_type_for_param(param.param_type);
        typed_ids.entry(param.id.as_str()).or_insert(value_type);
    }

    for (id, value_type) in &typed_ids {
        if *id == PARAMETER_ID_MAP_AUGMENTED_MARKER {
            anyhow::bail!(
                "Parameter id '{}' is reserved for TypeScript code generation",
                PARAMETER_ID_MAP_AUGMENTED_MARKER
            );
        }

        let id_literal = ts_interface_property_key(id)?;
        content.push_str("    ");
        content.push_str(&id_literal);
        content.push_str(": ");
        content.push_str(value_type);
        content.push_str(";\n");
    }

    content.push_str("  }\n");
    content.push_str("}\n\n");
    content.push_str("export {};\n");

    let out_file = generated_dir.join("parameters.ts");
    let should_write = match fs::read_to_string(&out_file) {
        Ok(existing) => existing != content,
        Err(_) => true,
    };

    if should_write {
        fs::write(&out_file, content).with_context(|| {
            format!(
                "Failed to write generated TypeScript parameter file: {}",
                out_file.display()
            )
        })?;
    }

    Ok(())
}

/// Generate TypeScript processor ID augmentation and runtime registry file.
///
/// Output path: `{ui_dir}/src/generated/processors.ts`
///
/// The file augments global `WavecraftProcessorIdMap` so `ProcessorId`
/// resolves to a typed union of processor IDs in both internal SDK source
/// modules and user project TypeScript compilation. It also registers
/// discovered processors at runtime for `useHasProcessor` and
/// `useAvailableProcessors` hooks.
pub fn write_processor_types(ui_dir: &Path, processors: &[ProcessorInfo]) -> Result<()> {
    let generated_dir = ui_dir.join("src").join("generated");
    fs::create_dir_all(&generated_dir).with_context(|| {
        format!(
            "Failed to create generated TypeScript directory: {}",
            generated_dir.display()
        )
    })?;

    let mut content = String::new();
    content.push_str("/**\n");
    content.push_str(" * Auto-generated by `wavecraft start` — DO NOT EDIT\n");
    content.push_str(" *\n");
    content.push_str(" * Type-safe processor IDs for your plugin signal chain.\n");
    content.push_str(" * Regenerated automatically when Rust source files change.\n");
    content.push_str(" */\n\n");

    content.push_str("import { registerAvailableProcessors } from '@wavecraft/core';\n\n");

    content.push_str("declare global {\n");
    content.push_str("  interface WavecraftProcessorIdMap {\n");
    content.push_str("    ");
    content.push_str(PROCESSOR_ID_MAP_AUGMENTED_MARKER);
    content.push_str(": true;\n");

    let mut typed_ids: BTreeMap<&str, bool> = BTreeMap::new();
    for processor in processors {
        typed_ids.entry(processor.id.as_str()).or_insert(true);
    }

    for id in typed_ids.keys() {
        if *id == PROCESSOR_ID_MAP_AUGMENTED_MARKER {
            anyhow::bail!(
                "Processor id '{}' is reserved for TypeScript code generation",
                PROCESSOR_ID_MAP_AUGMENTED_MARKER
            );
        }

        let id_literal = ts_interface_property_key(id)?;
        content.push_str("    ");
        content.push_str(&id_literal);
        content.push_str(": true;\n");
    }

    content.push_str("  }\n");
    content.push_str("}\n\n");

    content.push_str("const PROCESSOR_IDS = [\n");
    for id in typed_ids.keys() {
        content.push_str("  ");
        content.push_str(&ts_string_literal(id)?);
        content.push_str(",\n");
    }
    content.push_str("] as const;\n\n");
    content.push_str("registerAvailableProcessors(PROCESSOR_IDS);\n\n");
    content.push_str("export {};\n");

    let out_file = generated_dir.join("processors.ts");
    let should_write = match fs::read_to_string(&out_file) {
        Ok(existing) => existing != content,
        Err(_) => true,
    };

    if should_write {
        fs::write(&out_file, content).with_context(|| {
            format!(
                "Failed to write generated TypeScript processor file: {}",
                out_file.display()
            )
        })?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use wavecraft_protocol::ParameterType;

    fn param(id: &str) -> ParameterInfo {
        ParameterInfo {
            id: id.to_string(),
            name: "Test".to_string(),
            param_type: ParameterType::Float,
            value: 0.5_f32,
            default: 0.5_f32,
            min: 0.0,
            max: 1.0,
            unit: None,
            group: None,
            variants: None,
        }
    }

    #[test]
    fn writes_deterministic_sorted_output() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        let params = vec![param("b_id"), param("a_id"), param("b_id")];
        write_parameter_types(ui_dir, &params).expect("write should succeed");

        let output_path = ui_dir.join("src/generated/parameters.ts");
        let output = fs::read_to_string(output_path).expect("generated file should exist");

        let a_pos = output.find("a_id: number;").expect("a_id present");
        let b_pos = output.find("b_id: number;").expect("b_id present");

        assert!(a_pos < b_pos, "IDs should be sorted");
        assert_eq!(
            output.matches("b_id: number;").count(),
            1,
            "IDs deduplicated"
        );
        assert!(
            output.contains("__wavecraft_internal_augmented__: true;"),
            "augmentation marker should always be present"
        );
    }

    #[test]
    fn writes_marker_only_for_empty_param_list() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        write_parameter_types(ui_dir, &[]).expect("write should succeed");

        let output_path = ui_dir.join("src/generated/parameters.ts");
        let output = fs::read_to_string(output_path).expect("generated file should exist");

        assert!(
            output.contains("__wavecraft_internal_augmented__: true;"),
            "marker should be present for augmented-empty mode"
        );
        assert_eq!(
            output.matches(": true;").count(),
            1,
            "only marker entry should be generated for empty list"
        );
    }

    #[test]
    fn emits_prettier_stable_property_keys_for_typescript() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        let params = vec![
            param("gain"),
            param("gain-db"),
            param("gain\"quoted\\slash"),
        ];
        write_parameter_types(ui_dir, &params).expect("write should succeed");

        let output_path = ui_dir.join("src/generated/parameters.ts");
        let output = fs::read_to_string(output_path).expect("generated file should exist");

        assert!(
            output.contains("gain: number;"),
            "valid identifier keys should be unquoted"
        );
        assert!(
            output.contains("'gain-db': number;"),
            "non-identifier keys should remain quoted"
        );
        assert!(
            output.contains("'gain\"quoted\\\\slash': number;"),
            "quoted keys should be escaped as valid TypeScript string literals"
        );
    }

    #[test]
    fn emits_boolean_value_types_for_bool_parameters() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        let params = vec![
            ParameterInfo {
                id: "enabled".to_string(),
                name: "Enabled".to_string(),
                param_type: ParameterType::Bool,
                value: 0.0,
                default: 0.0,
                min: 0.0,
                max: 1.0,
                unit: None,
                group: None,
                variants: None,
            },
            param("level"),
        ];

        write_parameter_types(ui_dir, &params).expect("write should succeed");

        let output_path = ui_dir.join("src/generated/parameters.ts");
        let output = fs::read_to_string(output_path).expect("generated file should exist");

        assert!(output.contains("enabled: boolean;"));
        assert!(output.contains("level: number;"));
    }

    #[test]
    fn errors_on_reserved_marker_id_collision() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        let err = write_parameter_types(ui_dir, &[param(PARAMETER_ID_MAP_AUGMENTED_MARKER)])
            .expect_err("reserved id should be rejected");

        assert!(
            err.to_string().contains("reserved"),
            "error should explain reserved marker collision"
        );
    }

    fn processor(id: &str) -> ProcessorInfo {
        ProcessorInfo { id: id.to_string() }
    }

    #[test]
    fn writes_deterministic_sorted_processor_output() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        let processors = vec![
            processor("output_gain"),
            processor("oscillator"),
            processor("output_gain"),
        ];
        write_processor_types(ui_dir, &processors).expect("write should succeed");

        let output_path = ui_dir.join("src/generated/processors.ts");
        let output = fs::read_to_string(output_path).expect("generated file should exist");

        let oscillator_pos = output
            .find("oscillator: true;")
            .expect("oscillator present");
        let output_gain_pos = output
            .find("output_gain: true;")
            .expect("output_gain present");

        assert!(oscillator_pos < output_gain_pos, "IDs should be sorted");
        assert_eq!(
            output.matches("output_gain: true;").count(),
            1,
            "IDs deduplicated"
        );
        assert!(
            output.contains("registerAvailableProcessors(PROCESSOR_IDS);"),
            "runtime registration should be emitted"
        );
    }

    #[test]
    fn writes_marker_only_for_empty_processor_list() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        write_processor_types(ui_dir, &[]).expect("write should succeed");

        let output_path = ui_dir.join("src/generated/processors.ts");
        let output = fs::read_to_string(output_path).expect("generated file should exist");

        assert!(
            output.contains("__wavecraft_internal_processors_augmented__: true;"),
            "marker should be present for augmented-empty mode"
        );
        assert!(
            output.contains("const PROCESSOR_IDS = [\n] as const;"),
            "empty processor array should still be emitted"
        );
    }

    #[test]
    fn errors_on_reserved_processor_marker_id_collision() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        let err = write_processor_types(ui_dir, &[processor(PROCESSOR_ID_MAP_AUGMENTED_MARKER)])
            .expect_err("reserved id should be rejected");

        assert!(
            err.to_string().contains("reserved"),
            "error should explain reserved marker collision"
        );
    }

    #[test]
    fn emits_prettier_stable_processor_string_literals() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        let processors = vec![
            processor("gain-stage"),
            processor("gain\"quoted\\slash"),
            processor("gain'single"),
        ];
        write_processor_types(ui_dir, &processors).expect("write should succeed");

        let output_path = ui_dir.join("src/generated/processors.ts");
        let output = fs::read_to_string(output_path).expect("generated file should exist");

        assert!(output.contains("'gain-stage'"));
        assert!(output.contains("'gain\"quoted\\\\slash'"));
        assert!(output.contains("'gain\\'single'"));
    }
}
