//! TypeScript code generation utilities.
//!
//! Generates `ui/src/generated/parameters.ts` with module augmentation for
//! `@wavecraft/core` so parameter IDs are available as IDE autocomplete.

use std::collections::BTreeMap;
use std::fs;
use std::path::Path;

use anyhow::{Context, Result};
use wavecraft_protocol::{ParameterInfo, ParameterType};

const PARAMETER_ID_MAP_AUGMENTED_MARKER: &str = "__wavecraft_internal_augmented__";

fn ts_string_literal(value: &str) -> Result<String> {
    serde_json::to_string(value).context("Failed to escape TypeScript string literal")
}

fn is_ascii_typescript_identifier(value: &str) -> bool {
    let mut chars = value.chars();

    let Some(first) = chars.next() else {
        return false;
    };

    if !(first.is_ascii_alphabetic() || first == '_' || first == '$') {
        return false;
    }

    chars.all(|ch| ch.is_ascii_alphanumeric() || ch == '_' || ch == '$')
}

fn ts_interface_property_key(value: &str) -> Result<String> {
    if is_ascii_typescript_identifier(value) {
        Ok(value.to_string())
    } else {
        ts_string_literal(value)
    }
}

fn ts_value_type_for_param(param_type: ParameterType) -> &'static str {
    match param_type {
        ParameterType::Bool => "boolean",
        ParameterType::Float | ParameterType::Enum => "number",
    }
}

/// Generate TypeScript parameter ID augmentation file.
///
/// Output path: `{ui_dir}/src/generated/parameters.ts`
///
/// The file augments `@wavecraft/core`'s `ParameterIdMap` interface so
/// `ParameterId` resolves to a typed union of parameter IDs in the user's
/// project TypeScript compilation.
pub fn write_parameter_types(ui_dir: &Path, params: &[ParameterInfo]) -> Result<()> {
    let generated_dir = ui_dir.join("src").join("generated");
    fs::create_dir_all(&generated_dir).with_context(|| {
        format!(
            "Failed to create generated TypeScript directory: {}",
            generated_dir.display()
        )
    })?;

    let mut content = String::new();
    content.push_str("/**\n");
    content.push_str(" * Auto-generated by `wavecraft start` â€” DO NOT EDIT\n");
    content.push_str(" *\n");
    content.push_str(" * Type-safe parameter IDs for your plugin.\n");
    content.push_str(" * Regenerated automatically when Rust source files change.\n");
    content.push_str(" */\n\n");

    content.push_str("declare module '@wavecraft/core' {\n");
    content.push_str("  interface ParameterIdMap {\n");
    content.push_str("    ");
    content.push_str(PARAMETER_ID_MAP_AUGMENTED_MARKER);
    content.push_str(": true;\n");

    let mut typed_ids: BTreeMap<&str, &str> = BTreeMap::new();
    for param in params {
        let value_type = ts_value_type_for_param(param.param_type);
        typed_ids.entry(param.id.as_str()).or_insert(value_type);
    }

    for (id, value_type) in &typed_ids {
        if *id == PARAMETER_ID_MAP_AUGMENTED_MARKER {
            anyhow::bail!(
                "Parameter id '{}' is reserved for TypeScript code generation",
                PARAMETER_ID_MAP_AUGMENTED_MARKER
            );
        }

        let id_literal = ts_interface_property_key(id)?;
        content.push_str("    ");
        content.push_str(&id_literal);
        content.push_str(": ");
        content.push_str(value_type);
        content.push_str(";\n");
    }

    content.push_str("  }\n");
    content.push_str("}\n\n");
    content.push_str("export {};\n");

    let out_file = generated_dir.join("parameters.ts");
    let should_write = match fs::read_to_string(&out_file) {
        Ok(existing) => existing != content,
        Err(_) => true,
    };

    if should_write {
        fs::write(&out_file, content).with_context(|| {
            format!(
                "Failed to write generated TypeScript parameter file: {}",
                out_file.display()
            )
        })?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use wavecraft_protocol::ParameterType;

    fn param(id: &str) -> ParameterInfo {
        ParameterInfo {
            id: id.to_string(),
            name: "Test".to_string(),
            param_type: ParameterType::Float,
            value: 0.5_f32,
            default: 0.5_f32,
            min: 0.0,
            max: 1.0,
            unit: None,
            group: None,
        }
    }

    #[test]
    fn writes_deterministic_sorted_output() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        let params = vec![param("b_id"), param("a_id"), param("b_id")];
        write_parameter_types(ui_dir, &params).expect("write should succeed");

        let output_path = ui_dir.join("src/generated/parameters.ts");
        let output = fs::read_to_string(output_path).expect("generated file should exist");

        let a_pos = output.find("a_id: number;").expect("a_id present");
        let b_pos = output.find("b_id: number;").expect("b_id present");

        assert!(a_pos < b_pos, "IDs should be sorted");
        assert_eq!(
            output.matches("b_id: number;").count(),
            1,
            "IDs deduplicated"
        );
        assert!(
            output.contains("__wavecraft_internal_augmented__: true;"),
            "augmentation marker should always be present"
        );
    }

    #[test]
    fn writes_marker_only_for_empty_param_list() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        write_parameter_types(ui_dir, &[]).expect("write should succeed");

        let output_path = ui_dir.join("src/generated/parameters.ts");
        let output = fs::read_to_string(output_path).expect("generated file should exist");

        assert!(
            output.contains("__wavecraft_internal_augmented__: true;"),
            "marker should be present for augmented-empty mode"
        );
        assert_eq!(
            output.matches(": true;").count(),
            1,
            "only marker entry should be generated for empty list"
        );
    }

    #[test]
    fn emits_prettier_stable_property_keys_for_typescript() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        let params = vec![
            param("gain"),
            param("gain-db"),
            param("gain\"quoted\\slash"),
        ];
        write_parameter_types(ui_dir, &params).expect("write should succeed");

        let output_path = ui_dir.join("src/generated/parameters.ts");
        let output = fs::read_to_string(output_path).expect("generated file should exist");

        assert!(
            output.contains("gain: number;"),
            "valid identifier keys should be unquoted"
        );
        assert!(
            output.contains("\"gain-db\": number;"),
            "non-identifier keys should remain quoted"
        );
        assert!(
            output.contains("\"gain\\\"quoted\\\\slash\": number;"),
            "quoted keys should be escaped as valid TypeScript string literals"
        );
    }

    #[test]
    fn emits_boolean_value_types_for_bool_parameters() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        let params = vec![
            ParameterInfo {
                id: "enabled".to_string(),
                name: "Enabled".to_string(),
                param_type: ParameterType::Bool,
                value: 0.0,
                default: 0.0,
                min: 0.0,
                max: 1.0,
                unit: None,
                group: None,
            },
            param("level"),
        ];

        write_parameter_types(ui_dir, &params).expect("write should succeed");

        let output_path = ui_dir.join("src/generated/parameters.ts");
        let output = fs::read_to_string(output_path).expect("generated file should exist");

        assert!(output.contains("enabled: boolean;"));
        assert!(output.contains("level: number;"));
    }

    #[test]
    fn errors_on_reserved_marker_id_collision() {
        let temp = tempfile::tempdir().expect("temp dir");
        let ui_dir = temp.path();

        let err = write_parameter_types(ui_dir, &[param(PARAMETER_ID_MAP_AUGMENTED_MARKER)])
            .expect_err("reserved id should be rejected");

        assert!(
            err.to_string().contains("reserved"),
            "error should explain reserved marker collision"
        );
    }
}
