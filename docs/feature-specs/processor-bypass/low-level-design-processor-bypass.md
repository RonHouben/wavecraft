# Low-Level Design: Processor Bypass

## Related Documents

- [High-Level Design](../../architecture/high-level-design.md) — Architecture overview
- [Coding Standards](../../architecture/coding-standards.md) — Project conventions
- [Roadmap](../../roadmap.md) — Milestones and progress
- [SDK Architecture](../../architecture/sdk-architecture.md) — SDK/package boundaries
- [Development Workflows](../../architecture/development-workflows.md) — Dev/build/test flow
- [Plugin Formats](../../architecture/plugin-formats.md) — VST3/CLAP/AU integration details
- [User Stories: Processor Bypass](./user-stories.md) — Product requirements

---

## Overview

This feature introduces **framework-level processor bypass** as a **parameter-level capability** for every processor instance in `SignalChain![]`, with:

- dry passthrough when bypassed
- per-instance independence
- DAW automation compatibility
- DAW/session persistence through existing host parameter state
- zero required changes in existing processor implementations

UI visuals remain intentionally open; this design only defines stable contracts and hooks.

---

## Constraints & Invariants

1. **Real-time safety is non-negotiable**  
   No allocations/locks/syscalls in audio `process()` path.
2. **Bypass is parameter-driven**  
   No new processor-level IPC methods.
3. **Per-instance, not per-type**  
   IDs and state are keyed by processor instance prefix (existing naming flow).
4. **Host remains source of truth**  
   Persistence, automation, undo/redo are host-managed via existing parameter model.
5. **Backward compatibility**  
   Existing non-bypass parameters and processor code continue to work unchanged.

---

## Architecture Decisions

### AD-1: Inject one bypass parameter per processor instance

For each processor instance prefix (e.g. `input_trim`, `tone_filter`), inject:

- ID: `{processor_id}_bypass` (canonical Wavecraft ID style)
- type: boolean (`ParameterType::Bool`)
- range: stepped 0..1
- default: `0` (active, not bypassed)
- display name: `"{Processor Display Name} Bypass"` in host-facing parameter list

**Why:** aligns with existing underscore ID conventions and current codegen/IPC contracts.

---

### AD-2: Bypass implemented by a wrapper/combinator, not processor code changes

Introduce an internal wrapper (`Bypassed<P>`) around each chain processor, generated by macro expansion for DSL plugin flow.

Wrapper behavior:

- If bypass steady-state = true: **skip child `process()`**
- If bypass steady-state = false: call child `process()`
- On toggle transitions: run a short click-suppression transition (see AD-3)

**Why:** preserves current processor trait API and keeps bypass as framework concern.

---

### AD-3: Click-safe transitions via bounded crossfade state machine

To satisfy "no clicks/pops" expectation, bypass toggles use a tiny transition window:

- `ACTIVE`
- `BYPASSED`
- `TO_BYPASSED(n)`
- `TO_ACTIVE(n)`

Transition length is fixed and small (e.g. 32–128 samples, final value decided in implementation benchmarking). During transition only, blend dry/wet. Outside transition, bypassed processors are fully skipped.

**CPU contract:**

- steady bypassed = no child DSP cost
- short transition incurs temporary blend cost only around toggle edge

---

### AD-4: No IPC surface expansion

No new IPC methods. Existing methods remain sufficient:

- `getParameter`
- `setParameter`
- `getAllParameters`
- `parameterChanged` notifications

**Why:** already matches user-story scope and avoids protocol/API churn.

---

### AD-5: Host automation/persistence via standard parameter registration

Bypass parameters are regular host-exposed params in generated runtime parameter map (`param_map()`), so:

- automation lanes are available in DAW
- session save/restore persists bypass state
- undo/redo follows host parameter lifecycle

No custom serialization path is added.

---

## Data Model

## Parameter naming

Canonical ID format stays underscore-based:

- `input_trim_bypass`
- `tone_filter_bypass`
- `soft_clip_bypass`

> Note: stories use `{processor_id}:bypass` as illustrative text; this design standardizes to existing runtime convention `{processor_id}_bypass`.

## Parameter metadata

For each bypass param:

- `id`: `${processor_id}_bypass`
- `name`: `${ProcessorDisplayName} Bypass`
- `type`: `bool`
- `default`: `0.0`
- `min`: `0.0`
- `max`: `1.0`
- `group`: same processor group namespace used by the instance's params (or processor group fallback)

## Runtime value mapping

- backend transport remains numeric (`f32`) for protocol consistency
- UI hooks convert bool↔number using existing logic (`>= 0.5` threshold for bool)

---

## Engine Design (Rust)

### 1) Macro-layer injection points

In `wavecraft-macros` generation path:

- extend runtime parameter blocks to append bypass param per processor instance
- extend FFI metadata export (`wavecraft_get_params_json`) to include bypass params
- keep processor ID discovery unchanged (`wavecraft_get_processors_json`)

### 2) Processing topology

Generated signal chain type is internally wrapped so each processor instance is bypass-capable, while public DSL syntax remains unchanged.

Developer still writes:

`SignalChain![InputTrim, ToneFilter, ...]`

Generated processing path effectively behaves like:

`SignalChain![Bypassed<InputTrim>, Bypassed<ToneFilter>, ...]`

### 3) Bypass transition algorithm

Per wrapped processor instance maintain:

- current bypass target (bool)
- transition state and remaining samples
- minimal transition coefficients/state

Steady bypass = dry passthrough and child process skip.

### 4) Built-ins and custom processors

No change required for:

- built-in processors (`Gain`, `Filter`, `Saturator`, `Passthrough`, `Oscillator`, `OscilloscopeTap`)
- custom processors implementing `Processor`

---

## Protocol & Bridge Impact

## Protocol (`wavecraft-protocol`)

No schema change needed; existing `ParameterInfo` supports bool type and current value/default/min/max.

## Bridge (`wavecraft-nih_plug`, `wavecraft-bridge`)

No new methods. Existing `ParameterHost::set_parameter` and `get_all_parameters` naturally include bypass parameters once registered by generated params.

---

## UI/Core SDK Impact

1. **No transport API changes**
2. `useParameter('{processor_id}_bypass')` works out of the box
3. generated `ui/src/generated/parameters.ts` includes bypass IDs for type-safe usage
4. DAW automation updates reflected through existing `parameterChanged` flow

---

## UX Hook Interfaces (visual design intentionally open)

The architecture exposes stable hooks for future UX designer work without prescribing component visuals.

Recommended non-visual contract additions in `@wavecraft/core` (optional but useful):

- `isBypassParameterId(id: ParameterId): boolean`
- `getProcessorBypassParamId(processorId: ProcessorId): ParameterId`
- `useProcessorBypass(processorId: ProcessorId)` returning:
  - `bypassed: boolean`
  - `setBypassed(next: boolean): Promise<void>`
  - `isLoading`
  - `error`

These are API-level affordances only; no mandated visual pattern.

---

## Automation, Persistence, and Undo/Redo Behavior

Expected behavior (host-driven):

- bypass parameters appear in DAW automation lane list
- automation writes/readbacks through existing param pipeline
- session save/restore persists bypass flags
- host undo/redo manipulates bypass like any automatable parameter

No custom bypass state store is introduced.

---

## Real-Time Safety Notes

- no allocation in `process()`
- no locking in audio thread path
- no syscalls/logging in audio thread
- bypass check is constant-time (`bool` from current parameter frame)
- transition handling uses pre-initialized scalar state only
- steady-state bypass does not execute child DSP

---

## Migration Strategy

1. **Generated plugins:** auto-gain bypass params on rebuild (no user code changes)
2. **Existing parameter IDs:** remain unchanged; bypass adds new IDs only
3. **UI apps:** can ignore new params safely; generic UIs will surface them automatically
4. **Template updates:** sdk-template demonstrates bypass-ready control hooks without forcing a specific look
5. **Legacy aliasing (`param_n`)** remains untouched; bypass IDs are only emitted in canonical IDs

---

## Acceptance Mapping to User Stories

| Story | Acceptance                           | Design mapping                                                         |
| ----- | ------------------------------------ | ---------------------------------------------------------------------- |
| US1   | Auto bypass per processor            | Macro injects `${processor_id}_bypass` for every SignalChain instance  |
| US1   | Bool + naming + discoverable         | `Stepped 0..1` → `ParameterType::Bool`, included in `getAllParameters` |
| US1   | Existing processors unchanged        | Wrapper/combinator approach avoids processor trait changes             |
| US1   | SDK template support                 | Template consumes generated bypass IDs and leaves visuals open         |
| US2   | `process()` not called when bypassed | Wrapper skips child DSP in steady bypassed state                       |
| US2   | Dry passthrough                      | Wrapper outputs dry signal unmodified when bypassed                    |
| US2   | No clicks/pops                       | transition state machine with short crossfade                          |
| US2   | Mid-stream toggles                   | transition logic runs while streaming                                  |
| US2   | Zero extra CPU when bypassed         | child skipped in steady bypassed state                                 |
| US2   | Works for all built-ins              | wrapper is generic over all processor types                            |
| US3   | Persistence                          | standard host parameter persistence                                    |
| US3   | Restore + undo/redo + default false  | default=0, host-managed param lifecycle                                |
| US4   | DAW automation                       | bypass exposed as regular host parameter                               |
| US4   | lane visibility + recording workflow | names are host-visible and automatable                                 |
| US5   | UI via existing IPC/hooks            | no new IPC, existing `useParameter` works                              |
| US5   | DAW automation reflected in UI       | `parameterChanged` path already updates hooks                          |
| US6   | Per-instance independence            | IDs keyed by processor instance prefix                                 |
| US6   | Same type processors independent     | each wrapper instance has own bypass param/state                       |

---

## Testing & Verification Plan (design-level)

- engine unit tests:
  - bypassed stage skips child process invocation
  - active stage invokes child
  - transition has no discontinuity spikes at toggle edges
- chain integration tests:
  - two same-type processors have distinct bypass IDs/states
- protocol/bridge tests:
  - `getAllParameters` includes bypass metadata (`bool`, default, ranges)
- UI/core tests:
  - `useParameter` roundtrip for bypass bool
  - automation notification updates bypass value in hook state
- manual DAW verification (Ableton primary):
  - lane discovery, record automation, playback, save/reopen, undo/redo

---

## Risks & Mitigations

1. **toggle artifacts still audible in edge cases**  
   Mitigation: tune transition length + add regression audio tests.
2. **parameter list growth for large chains**  
   Mitigation: expected/acceptable; bool params are lightweight.
3. **analysis processors (e.g. OscilloscopeTap) bypass semantics confusion**  
   Mitigation: document behavior: bypass affects stage processing/output contribution and may suspend that stage's analysis output.

---

## Open Questions

1. Preferred default transition length (32, 64, or 128 samples) for best artifact/latency tradeoff?
2. Should analysis-only processors expose bypass in UI by default, or be hidden via metadata hint?
3. Should bypass parameters be grouped under a dedicated "Bypass" subgroup or processor's existing group?
4. Do we want an explicit utility hook in `@wavecraft/core` now, or leave as follow-up UX/API slice?

---

## Non-goals

- dynamic signal chain mutation/reordering
- wet/dry blend controls
- visual component prescription (button style, placement, animation)
