# Low-Level Design — Build-Time Parameter Discovery

## Problem Statement

The `wavecraft start` command currently discovers plugin parameters by loading the compiled `.dylib` via `libloading` and calling FFI functions (`wavecraft_get_params_json`). When the dynamic library is loaded, macOS executes constructor functions registered by `nih_export_vst3!` and `nih_export_clap!` — these are nih-plug's static initializers for VST3/CLAP factory registration. On macOS, this can trigger `AudioComponentRegistrar` or other system-level audio subsystem interactions that **block indefinitely** or take unpredictable amounts of time, causing `wavecraft start` to hang at "Loading plugin parameters...".

This is a fundamental issue: the dev server needs parameter metadata, but the only way to get it is to load a binary that also initializes a full plugin host interface — something designed for DAW contexts, not CLI tooling.

## Solution Overview

Replace FFI-based parameter discovery with a **build-time sidecar JSON file**. The `wavecraft_plugin!` macro already has full knowledge of the parameter metadata at compile time. Rather than loading the plugin binary to extract this metadata at runtime, we emit it as a JSON file during compilation, and the `wavecraft start` command reads the file directly.

```
┌──────────────────────────────────────┐
│            BEFORE (current)          │
│                                      │
│  cargo build ──► plugin.dylib        │
│                        │             │
│  wavecraft start       │             │
│    └─► dlopen(dylib) ──┘             │
│         │ ← triggers nih-plug init   │
│         │ ← AudioComponentRegistrar  │
│         │ ← BLOCKS / HANGS           │
│         ▼                            │
│    FFI: wavecraft_get_params_json()  │
│         │                            │
│         ▼                            │
│    DevServerHost(params)             │
└──────────────────────────────────────┘

┌──────────────────────────────────────┐
│            AFTER (proposed)          │
│                                      │
│  cargo build ──► plugin.dylib        │
│       │                              │
│       └──► build.rs / macro writes   │
│            wavecraft-params.json     │
│                                      │
│  wavecraft start                     │
│    └─► read("wavecraft-params.json") │
│         │  ← no dlopen, no FFI       │
│         │  ← no nih-plug init        │
│         │  ← instant, deterministic  │
│         ▼                            │
│    DevServerHost(params)             │
│                                      │
│    (dylib still loaded later for     │
│     audio-dev FFI vtable only)       │
└──────────────────────────────────────┘
```

## Design Constraints

1. **Backward compatibility.** Existing plugins that don't generate the sidecar file must still work. The CLI should fall back to FFI-based loading if the JSON file is not found.

2. **Zero user friction.** The sidecar file must be generated automatically by the existing `cargo build` step — no new build commands, no manual steps.

3. **Consistency.** The sidecar JSON must contain the same data as the FFI export. The source of truth is the `ProcessorParams::param_specs()` implementation.

4. **No new dependencies.** The build.rs approach should not introduce new crate dependencies for the user's plugin.

5. **Audio-dev FFI remains separate.** The `DevProcessorVTable` FFI (for in-process audio) still requires loading the dylib. This design only replaces the parameter discovery path.

## Recommended Design: Cargo Feature Gate on nih-plug Exports

This is the simplest solution that works reliably:

### 1. Add `_param-discovery` Feature to User's Plugin

```toml
# User's Cargo.toml (generated by template)
[features]
default = []
_param-discovery = []   # Internal: skip nih-plug exports for fast param loading
```

### 2. Macro Conditionally Emits nih-plug Exports

In the `wavecraft_plugin!` macro output:

```rust
// FFI exports — always generated
#[unsafe(no_mangle)]
pub extern "C" fn wavecraft_get_params_json() -> *mut c_char { ... }

#[unsafe(no_mangle)]
pub unsafe extern "C" fn wavecraft_free_string(ptr: *mut c_char) { ... }

// Plugin exports — only when NOT in param-discovery mode
#[cfg(not(feature = "_param-discovery"))]
nih_export_clap!(__WavecraftPlugin);

#[cfg(not(feature = "_param-discovery"))]
nih_export_vst3!(__WavecraftPlugin);
```

### 3. `wavecraft start` Uses Two-Phase Build

```
Phase 1: Fast param discovery (no nih-plug static init)
  cargo build --lib --features _param-discovery
  dlopen → wavecraft_get_params_json() → instant, no hang
  close dylib

Phase 2: Full plugin build (background, if audio-dev needed)
  cargo build --lib
  dlopen → wavecraft_dev_create_processor() → audio FFI
```

### 4. Cache Invalidation Concern — Mitigated

Cargo feature changes on the cdylib target do cause relinking. However:

- **Phase 1** is a minimal build: only links the param discovery symbols. It's fast because the cdylib is small without nih-plug exports.
- **Phase 2** is the existing build — same as today.
- Cargo build cache is shared for all non-cdylib dependencies — only the final link step differs.

In practice, the overhead is one extra link step (~0.5–2s), which is acceptable to avoid an indefinite hang.

### 5. Sidecar JSON Cache

To avoid even the Phase 1 build on subsequent runs (when code hasn't changed):

```
Phase 1 build → dlopen → params JSON → write to target/wavecraft-params.json
Subsequent runs: if wavecraft-params.json exists AND is newer than dylib → skip Phase 1
```

### 6. Fallback for Existing Plugins

If neither the sidecar JSON file exists nor the `_param-discovery` feature is available (older SDK), fall back to the current behavior (load dylib with full nih-plug init). This preserves backward compatibility.

---

## Component Changes

### 1. `wavecraft-macros` (proc macro crate)

**File:** `engine/crates/wavecraft-macros/src/plugin.rs`

**Change:** Wrap `nih_export_*!` calls in `#[cfg(not(feature = "_param-discovery"))]`

```rust
// Current (always emitted):
#krate::__nih::nih_export_clap!(__WavecraftPlugin);
#krate::__nih::nih_export_vst3!(__WavecraftPlugin);

// New (conditionally emitted):
#[cfg(not(feature = "_param-discovery"))]
#krate::__nih::nih_export_clap!(__WavecraftPlugin);
#[cfg(not(feature = "_param-discovery"))]
#krate::__nih::nih_export_vst3!(__WavecraftPlugin);
```

### 2. SDK Template

**File:** `cli/sdk-templates/new-project/react/engine/Cargo.toml.template`

**Change:** Add `_param-discovery` feature

```toml
[features]
default = []
_param-discovery = []   # Used by `wavecraft start` for fast param loading
```

### 3. CLI `start` Command

**Change:** Implement two-phase param loading with sidecar cache

```rust
fn load_parameters(
    engine_dir: &Path,
    verbose: bool,
) -> Result<(Vec<ParameterInfo>, Option<PluginLoader>)> {
    // 1. Try reading cached sidecar JSON
    // 2. Build with _param-discovery feature (no nih-plug exports)
    // 3. Load dylib (safe — no nih-plug static initializers)
    // 4. Write sidecar JSON cache
    // 5. Return params
}
```

**Sidecar location:** `engine/target/debug/wavecraft-params.json`

**Cache validity:** Compare sidecar mtime vs. dylib mtime. If dylib is newer, re-extract.

### 4. CLI `PluginLoader`

**Change:** Add a method to load parameters from a JSON file (bypass FFI).

```rust
impl PluginParamLoader {
    /// Load parameters from a sidecar JSON file instead of FFI.
    pub fn load_params_from_file<P: AsRef<Path>>(
        json_path: P,
    ) -> Result<Vec<ParameterInfo>, PluginLoaderError> {
        let contents = std::fs::read_to_string(json_path.as_ref())?;
        let params: Vec<ParameterInfo> = serde_json::from_str(&contents)?;
        Ok(params)
    }
}
```

---

## Testing Strategy

1. **Unit test:** Compile plugin with `_param-discovery` feature, verify no `VST3_FACTORY` or `clap_entry` symbols in dylib (`nm -g`)
2. **Integration test:** `wavecraft start` with new feature successfully loads params without hang
3. **Regression test:** Remove `_param-discovery` feature, verify fallback to FFI still works
4. **Cache test:** Modify source, verify sidecar is regenerated on next run
5. **Template test:** `wavecraft create` produces projects with `_param-discovery` feature

---

## Documentation References

- [High-Level Design](../../architecture/high-level-design.md) — Architecture overview
- [Coding Standards](../../architecture/coding-standards.md) — Code conventions
- [SDK Architecture](../../architecture/sdk-architecture.md) — Crate structure and distribution
- [Development Workflows](../../architecture/development-workflows.md) — Build system and dev mode
- [Declarative Plugin DSL](../../architecture/declarative-plugin-dsl.md) — Macro system
