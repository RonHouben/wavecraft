# Low-Level Design — CD CLI Cascade Publish

**Status:** Draft  
**Created:** 2026-02-08  
**Author:** Architect Agent  
**Feature:** `cd-cli-cascade-publish`

---

## Problem Statement

The Wavecraft CLI (`wavecraft create`) is the sole entry point for SDK users. When a user scaffolds a new plugin, the generated project references SDK dependencies by **git tag** derived from the CLI version:

```toml
# Generated by `wavecraft create`
wavecraft = { package = "wavecraft-nih_plug", git = "...", tag = "wavecraft-cli-v0.8.5" }
```

```json
// Generated template
"@wavecraft/core": "^0.7.1",
"@wavecraft/components": "^0.7.1"
```

This means changes to engine crates, `@wavecraft/core`, or `@wavecraft/components` are **invisible to users** until a new CLI version is published with a corresponding git tag. Currently, publishing any package requires the developer to **manually bump the version in a PR**. If they don't, the CD pipeline skips publishing ("local is not ahead of published, skipping").

Two problems to solve:

1. **Manual version bumps are mechanical toil** — SDK distribution versions (CLI, npm packages) serve no semantic purpose at patch level; they exist only to trigger a release.
2. **CLI must always re-publish when any SDK package changes** — otherwise the git tag doesn't point to the latest SDK state.

---

## Goals

| Goal | Priority |
|------|----------|
| Eliminate manual version bumping for SDK distribution packages | High |
| CLI automatically re-publishes when any SDK package changes | High |
| Preserve intentional minor/major version bumps by developers | High |
| Prevent infinite CI loops from auto-bump commits | High |
| Keep the product version (engine workspace) manually controlled | High |

---

## Non-Goals

- Changing the plugin product version workflow (PO decides, Coder bumps `engine/Cargo.toml` workspace version)
- Changing the engine crate publishing mechanism (`cargo-workspaces --from-git` already handles this)
- Auto-bumping npm peer dependency ranges in templates (templates use `^` ranges, which are forward-compatible)

---

## Two Version Domains

This design formalizes the distinction between two versioning concerns:

```
┌─────────────────────────────────────────────────────────────────────┐
│                      VERSION DOMAINS                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   Product Version                                                   │
│   ───────────────                                                   │
│   Location:  engine/Cargo.toml [workspace.package] version          │
│   Owner:     PO decides → Coder bumps → Tester verifies            │
│   Purpose:   Communicates product significance to plugin users      │
│   Visible:   VersionBadge UI component                              │
│   Policy:    ✅ Remains manual (no change)                          │
│                                                                     │
│   Distribution Versions                                             │
│   ─────────────────────                                             │
│   Locations: cli/Cargo.toml, ui/packages/*/package.json             │
│   Owner:     CI auto-bumps patch; developers may bump minor/major   │
│   Purpose:   Triggers crates.io/npm releases, creates git tags      │
│   Visible:   Never shown to plugin end-users                        │
│   Policy:    ✅ Auto-bumped by CI (new behavior)                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Architecture

### Current Pipeline

```
  detect-changes
       │
       ├── cli changed?           ──► publish-cli     (if local > published)
       ├── engine changed?        ──► publish-engine   (cargo-workspaces)
       ├── npm-core changed?      ──► publish-npm-core (if local > published)
       └── npm-components changed? ─► publish-npm-components (if local > published)
```

**Problems:**
- Each publish job independently decides to skip if version isn't ahead
- CLI only triggers on its own source changes
- No cascade: engine/npm changes don't trigger CLI re-publish
- Developer must manually bump versions to unblock publishing

### Proposed Pipeline

```
                            detect-changes
                    ┌──────────────────────────┐
                    │ cli?  engine?  npm-core?  │
                    │ npm-components?           │
                    │                          │
                    │ any_sdk_changed =        │
                    │   cli || engine ||       │
                    │   npm-core ||            │
                    │   npm-components         │
                    └──┬──┬──┬──┬─────────────┘
                       │  │  │  │
     ┌─────────────────┘  │  │  └────────────────────────┐
     ▼                    ▼  ▼                           ▼
┌────────────┐    ┌─────────────┐           ┌──────────────────────┐
│ publish-   │    │ publish-    │           │ publish-npm-         │
│ engine     │    │ npm-core    │           │ components           │
│            │    │             │           │                      │
│ if engine  │    │ if npm-core │           │ if npm-components    │
│ || cli     │    │ auto-bumps  │           │ auto-bumps patch     │
│ (existing) │    │ patch if    │           │ if needed            │
└─────┬──────┘    │ needed      │           └──────────┬───────────┘
      │           └──────┬──────┘                      │
      │                  │                             │
      └────────┬─────────┴─────────────────────────────┘
               ▼
       ┌───────────────┐
       │  publish-cli  │
       │               │
       │  Triggers if  │
       │  ANY package  │
       │  changed      │
       │               │
       │  Auto-bumps   │
       │  patch if     │
       │  needed       │
       └───────┬───────┘
               │
               ▼
       Git tag: wavecraft-cli-vX.Y.Z
       (template references this tag)
```

---

## Detailed Changes

### Change 1: Auto-Bump Skip Guard

Add a workflow-level guard to prevent infinite loops from auto-bump commits re-triggering the pipeline.

**File:** `.github/workflows/continuous-deploy.yml`

```yaml
jobs:
  detect-changes:
    runs-on: ubuntu-latest
    # Skip if the triggering commit is an auto-bump from CI
    if: "!contains(github.event.head_commit.message, '[auto-bump]')"
    outputs:
      cli: ${{ steps.filter.outputs.cli }}
      engine: ${{ steps.filter.outputs.engine }}
      npm-core: ${{ steps.filter.outputs.npm-core }}
      npm-components: ${{ steps.filter.outputs.npm-components }}
      any_sdk_changed: ${{ steps.aggregate.outputs.any_sdk_changed }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            # ... existing filters unchanged ...

      - name: Compute aggregate flag
        id: aggregate
        run: |
          if [[ "${{ steps.filter.outputs.cli }}" == "true" || \
                "${{ steps.filter.outputs.engine }}" == "true" || \
                "${{ steps.filter.outputs.npm-core }}" == "true" || \
                "${{ steps.filter.outputs.npm-components }}" == "true" ]]; then
            echo "any_sdk_changed=true" >> $GITHUB_OUTPUT
          else
            echo "any_sdk_changed=false" >> $GITHUB_OUTPUT
          fi
```

**Rationale:** Using `[auto-bump]` as a commit message marker (instead of `[skip ci]`) so that other workflows (CI linting, template validation) still run on auto-bump commits. Only the CD workflow ignores them.

### Change 2: Auto-Bump Logic for npm Packages

Replace the "skip if not ahead" guard with auto-bump-then-publish logic.

**Applies to:** `publish-npm-core` and `publish-npm-components` jobs.

**Current "Determine publish version" step:**
```yaml
# Skips if local version is not ahead of npm
if npx --yes semver "$LOCAL" -r ">$LATEST" > /dev/null 2>&1; then
  echo "skip=false"
else
  echo "skip=true"  # ← This blocks publishing
fi
```

**Proposed replacement:**
```yaml
- name: Determine publish version
  id: version
  working-directory: ui/packages/core  # or components
  run: |
    LOCAL=$(node -p "require('./package.json').version")
    LATEST=$(npm view @wavecraft/core version 2>/dev/null || echo "0.0.0")
    echo "local=$LOCAL" >> $GITHUB_OUTPUT
    echo "latest=$LATEST" >> $GITHUB_OUTPUT
    
    if npx --yes semver "$LOCAL" -r ">$LATEST" > /dev/null 2>&1; then
      # Developer already bumped — publish as-is
      echo "needs_bump=false" >> $GITHUB_OUTPUT
      echo "publish_version=$LOCAL" >> $GITHUB_OUTPUT
    else
      # Auto-bump patch: take latest published and increment patch
      NEW=$(npx --yes semver "$LATEST" -i patch)
      echo "needs_bump=true" >> $GITHUB_OUTPUT
      echo "publish_version=$NEW" >> $GITHUB_OUTPUT
    fi

- name: Auto-bump patch version
  if: steps.version.outputs.needs_bump == 'true'
  working-directory: ui/packages/core  # or components
  run: |
    npm version ${{ steps.version.outputs.publish_version }} --no-git-tag-version
    
- name: Commit auto-bump
  if: steps.version.outputs.needs_bump == 'true'
  run: |
    git config user.name "github-actions[bot]"
    git config user.email "github-actions[bot]@users.noreply.github.com"
    git add ui/packages/core/package.json  # or components
    git commit -m "chore(npm): auto-bump @wavecraft/core to ${{ steps.version.outputs.publish_version }} [auto-bump]"
    git push origin main
```

The publish step then always runs (no `skip` guard needed — the job-level `if` already ensures files changed).

### Change 3: Auto-Bump Logic for CLI

Same pattern applied to the CLI crate.

**Proposed replacement for "Determine publish version":**
```yaml
- name: Determine publish version
  id: version
  run: |
    CURRENT=$(cargo metadata --manifest-path cli/Cargo.toml --no-deps --format-version 1 | jq -r '.packages[0].version')
    PUBLISHED=$(curl -s "https://index.crates.io/wa/ve/wavecraft" | tail -1 | jq -r '.vers' 2>/dev/null || echo "0.0.0")
    echo "current=$CURRENT" >> $GITHUB_OUTPUT
    echo "published=$PUBLISHED" >> $GITHUB_OUTPUT
    
    if [ "$(printf '%s\n' "$PUBLISHED" "$CURRENT" | sort -V | tail -1)" = "$CURRENT" ] && [ "$CURRENT" != "$PUBLISHED" ]; then
      # Developer already bumped — publish as-is
      echo "needs_bump=false" >> $GITHUB_OUTPUT
      echo "publish_version=$CURRENT" >> $GITHUB_OUTPUT
    else
      # Auto-bump: increment patch from published version
      MAJOR=$(echo "$PUBLISHED" | cut -d. -f1)
      MINOR=$(echo "$PUBLISHED" | cut -d. -f2)
      PATCH=$(echo "$PUBLISHED" | cut -d. -f3)
      NEW="$MAJOR.$MINOR.$((PATCH + 1))"
      echo "needs_bump=true" >> $GITHUB_OUTPUT
      echo "publish_version=$NEW" >> $GITHUB_OUTPUT
    fi

- name: Auto-bump CLI patch version
  if: steps.version.outputs.needs_bump == 'true'
  run: |
    CURRENT=${{ steps.version.outputs.current }}
    NEW=${{ steps.version.outputs.publish_version }}
    sed -i "s/^version = \"$CURRENT\"/version = \"$NEW\"/" cli/Cargo.toml
    git config user.name "github-actions[bot]"
    git config user.email "github-actions[bot]@users.noreply.github.com"
    git add cli/Cargo.toml
    git commit -m "chore(cli): auto-bump to $NEW [auto-bump]"
    git push origin main
```

### Change 4: CLI Cascade Trigger

Modify `publish-cli` to trigger on **any** SDK package change, not just CLI source changes. It must also wait for all upstream publish jobs.

**Current:**
```yaml
publish-cli:
  needs: [detect-changes, publish-engine]
  if: needs.detect-changes.outputs.cli == 'true' && always()
```

**Proposed:**
```yaml
publish-cli:
  needs: [detect-changes, publish-engine, publish-npm-core, publish-npm-components]
  if: |
    always() &&
    needs.detect-changes.outputs.any_sdk_changed == 'true' &&
    !cancelled() &&
    (needs.publish-engine.result == 'success' || needs.publish-engine.result == 'skipped') &&
    (needs.publish-npm-core.result == 'success' || needs.publish-npm-core.result == 'skipped') &&
    (needs.publish-npm-components.result == 'success' || needs.publish-npm-components.result == 'skipped')
```

**Rationale:**
- `any_sdk_changed == 'true'`: CLI publishes whenever **any** SDK component changed
- Waits for all upstream jobs via `needs`
- Only proceeds if upstream jobs succeeded or were skipped (not if they failed)
- `!cancelled()` prevents running if the workflow was manually cancelled

---

## Infinite Loop Prevention

Auto-bump commits push to `main`, which matches the `on: push: branches: [main]` trigger. Without mitigation, this creates an infinite loop.

### Solution: `[auto-bump]` Commit Message Marker

```
Commit: "chore(cli): auto-bump to 0.8.6 [auto-bump]"
          │                                    │
          │                                    └── Marker string
          └── Conventional commit format

detect-changes job:
  if: "!contains(github.event.head_commit.message, '[auto-bump]')"
          │
          └── Workflow starts but this job is skipped
              → All downstream jobs are skipped (they need detect-changes)
              → No publishing, no further commits
              → Loop terminated
```

### Why `[auto-bump]` over `[skip ci]`?

| Approach | Effect | Drawback |
|----------|--------|----------|
| `[skip ci]` | Skips **all** GitHub Actions workflows | CI lint, template validation also skipped — risky |
| `[auto-bump]` marker | Only CD workflow skips; other workflows run normally | Slightly more code, but targeted |

### Why Not Bot Actor Filtering?

GitHub Actions has a known behavior where `GITHUB_TOKEN`-based pushes don't trigger workflows by default. If the repository uses the default `GITHUB_TOKEN`, the auto-bump push may already not trigger workflows. However:

- This behavior is not guaranteed and depends on repository settings
- Some setups use PATs which **do** trigger workflows
- The `[auto-bump]` guard is explicit defense-in-depth regardless of token type

---

## Git Push from CI

### Requirement

Auto-bump steps need to `git push` to `main`. This requires:

1. The `GITHUB_TOKEN` has `contents: write` permission (already configured in each job)
2. Branch protection rules allow `github-actions[bot]` to push

### Current State

Each publish job already has:
```yaml
permissions:
  contents: write  # Required for version bump commits
```

And the checkout uses:
```yaml
- uses: actions/checkout@v4
  with:
    token: ${{ secrets.GITHUB_TOKEN }}
```

This should be sufficient. If branch protection blocks the push, the job will fail with a clear error, and the fix is a one-time GitHub settings change (allow `github-actions[bot]` to bypass branch protection).

### Git Conflict Prevention

Multiple auto-bump commits from the same pipeline run could conflict. Mitigation:

1. **Sequential jobs:** `publish-cli` depends on all upstream jobs via `needs`, so it runs last. Its auto-bump commit is the final one.
2. **Parallel npm jobs:** `publish-npm-core` and `publish-npm-components` could run in parallel. They modify different files (`ui/packages/core/package.json` vs `ui/packages/components/package.json`), so **no conflict** as long as each job does `git pull --rebase` before pushing.

Add a rebase step before each auto-bump push:

```yaml
- name: Commit auto-bump
  if: steps.version.outputs.needs_bump == 'true'
  run: |
    git config user.name "github-actions[bot]"
    git config user.email "github-actions[bot]@users.noreply.github.com"
    git add <file>
    git commit -m "chore(...): auto-bump to ... [auto-bump]"
    git pull --rebase origin main
    git push origin main
```

---

## Execution Order

The full pipeline execution for a scenario where **only engine crates changed**:

```
1. detect-changes
   ├── cli=false, engine=true, npm-core=false, npm-components=false
   └── any_sdk_changed=true

2. publish-engine (runs: engine=true)
   └── cargo ws publish --from-git (handles its own versioning)

3. publish-npm-core (skipped: npm-core=false)

4. publish-npm-components (skipped: npm-components=false)

5. publish-cli (runs: any_sdk_changed=true)
   ├── Detects: cli version 0.8.5 == crates.io 0.8.5
   ├── Auto-bumps: 0.8.5 → 0.8.6
   ├── Commits: "chore(cli): auto-bump to 0.8.6 [auto-bump]"
   ├── Pushes to main
   ├── Publishes 0.8.6 to crates.io
   └── Tags: wavecraft-cli-v0.8.6

6. Auto-bump commit triggers CD again
   └── detect-changes skips: message contains [auto-bump]
   └── Pipeline terminates
```

For a scenario where **all packages changed** (and developer manually bumped CLI to 0.9.0):

```
1. detect-changes
   ├── cli=true, engine=true, npm-core=true, npm-components=true
   └── any_sdk_changed=true

2. publish-engine (runs)

3. publish-npm-core (runs)
   ├── Detects: local 0.7.5 == npm 0.7.5
   ├── Auto-bumps: 0.7.5 → 0.7.6
   ├── Commits + pushes

4. publish-npm-components (runs, waits for npm-core)
   ├── Detects: local 0.7.4 == npm 0.7.4
   ├── Auto-bumps: 0.7.4 → 0.7.5
   ├── git pull --rebase (picks up npm-core commit)
   ├── Commits + pushes

5. publish-cli (runs, waits for all)
   ├── Detects: local 0.9.0 > crates.io 0.8.5
   ├── No auto-bump needed (developer's version is ahead)
   ├── git pull --rebase (picks up npm commits)
   ├── Publishes 0.9.0
   └── Tags: wavecraft-cli-v0.9.0
```

---

## Impact on Coding Standards

The **Versioning** section in `docs/architecture/coding-standards.md` needs an addendum:

### Addition: SDK Distribution Versioning

```
**SDK Distribution Versions** (CLI crate, npm packages) are auto-bumped by CI.

- **Patch versions**: Auto-bumped by the CD pipeline when files change but the
  local version is not ahead of the published version.
- **Minor/Major versions**: Developers bump manually in a PR when semantically 
  appropriate. CI respects the developer's version if it is already ahead.
- **Engine crates**: Continue using `cargo-workspaces --from-git` (no change).

The existing rule ("PO decides, Coder bumps") applies to the **plugin product version**
(engine/Cargo.toml workspace.package.version), NOT to SDK distribution versions.
```

---

## Impact on Template Dependencies

### Rust Template (Git Tag)

```toml
# cli/sdk-templates/new-project/react/engine/Cargo.toml.template
wavecraft = { package = "wavecraft-nih_plug", git = "...", tag = "{{sdk_version}}" }
```

`sdk_version` is resolved at `wavecraft create` time from the CLI's own version:

```rust
// cli/src/main.rs
const SDK_VERSION: &str = concat!("wavecraft-cli-v", env!("CARGO_PKG_VERSION"));
```

**No change needed.** When the CLI is auto-bumped to `0.8.6`, `env!("CARGO_PKG_VERSION")` becomes `0.8.6`, and the git tag `wavecraft-cli-v0.8.6` is pushed by the pipeline. The template resolves correctly.

### npm Template (Caret Ranges)

```json
// cli/sdk-templates/new-project/react/ui/package.json
"@wavecraft/core": "^0.7.1",
"@wavecraft/components": "^0.7.1"
```

**No change needed for patch bumps.** The `^0.7.1` range accepts any `0.7.x` where `x >= 1`. Auto-bumped patches (e.g., `0.7.5 → 0.7.6`) are automatically covered.

**Minor bumps require a template update.** If `@wavecraft/core` is manually bumped to `0.8.0`, the template's `^0.7.1` range would not match. This is an existing constraint that predates this feature — it requires a template PR regardless.

---

## Files Modified

| File | Change |
|------|--------|
| `.github/workflows/continuous-deploy.yml` | All four changes described above |
| `docs/architecture/coding-standards.md` | Add SDK distribution versioning rule |

No Rust or TypeScript code changes required.

---

## Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Auto-bump infinite loop | Low | High | `[auto-bump]` marker + `detect-changes` guard |
| Git push rejected by branch protection | Low | Medium | Verify `github-actions[bot]` has push permission |
| Parallel npm auto-bump commits conflict | Low | Medium | `git pull --rebase` before each push |
| Rapid patch accumulation | Medium | Low | Acceptable — patches are cheap and mechanical |
| `sed -i` Cargo.toml edit hits wrong line | Low | Medium | Match on `^version = ` in `[package]` section |
| Engine `cargo-workspaces` commit conflicts with npm auto-bump | Low | Medium | Engine publishes first (upstream `needs`); npm jobs rebase |

---

## Testing Strategy

### CI Workflow Testing

1. **Dry-run validation:** Each auto-bump step should log what it *would* do before actually pushing. Add `--dry-run` equivalent for debugging.
2. **Manual workflow_dispatch testing:** Trigger the CD workflow manually to test auto-bump logic without needing a real commit.
3. **Branch protection test:** After implementation, merge a trivial engine change and verify the full cascade fires.

### Scenario Matrix

| Scenario | Expected Behavior |
|----------|-------------------|
| Only engine crates changed | Engine publishes → CLI auto-bumps + publishes |
| Only npm-core changed | npm-core auto-bumps + publishes → CLI auto-bumps + publishes |
| Only npm-components changed | npm-components auto-bumps + publishes → CLI auto-bumps + publishes |
| Only CLI source changed | CLI publishes (existing behavior, may auto-bump if needed) |
| All packages changed, dev bumped CLI | All publish; CLI uses developer's version (no auto-bump) |
| Auto-bump commit pushed | detect-changes skips → pipeline terminates |
| No SDK files changed | detect-changes: all false → all jobs skipped |

---

## Related Documents

- [High-Level Design](../../architecture/high-level-design.md) — SDK distribution model, version flow
- [Coding Standards](../../architecture/coding-standards.md) — Versioning rules
- [CD Pipeline Guide](../../guides/ci-pipeline.md) — CI/CD overview
