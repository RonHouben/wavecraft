# High-Level Design — React UI for a Rust VST Plugin

⸻

## Related Documents

- [Coding Standards](./coding-standards.md) — Conventions for TypeScript, Rust, and React code
- [Roadmap](../roadmap.md) — Project milestones and implementation plan
- [macOS Signing Guide](../guides/macos-signing.md) — Code signing and notarization setup
- [Visual Testing Guide](../guides/visual-testing.md) — Browser-based visual testing with Playwright
- [SDK Getting Started](../guides/sdk-getting-started.md) — Building plugins with Wavecraft SDK

⸻

## Assumptions (explicit)
	•	**Primary target:** macOS + Ableton Live (VST3). Windows and Linux are deprioritized.
	•	Audio engine / DSP will be implemented in Rust.
	•	UI must be built in React (single-page app, built with Vite/webpack/etc) and embedded inside the plugin UI window (not a separate app).
	•	Plugin formats to support: VST3 (primary via nih-plug), CLAP (secondary via nih-plug), AU (nice-to-have via clap-wrapper for Logic Pro).
	•	No Electron or Tauri; prefer a lightweight embedded webview or an equivalent approach.
	•	Focus on production-ready macOS support first; cross-platform is a future consideration.

> **Note on AU support:** nih-plug does not export AU directly. AU plugins are generated by wrapping the CLAP output using [clap-wrapper](https://github.com/free-audio/clap-wrapper/). This is the community-recommended approach. See the "Audio Unit (AU) Architecture" section for details.

⸻

## Executive summary (one paragraph)

Build the audio/DSP core and host/plugin API surface in Rust (use a modern Rust plugin framework such as nih-plug), expose a minimal parameter and event API, and embed a React frontend by bundling the built static assets into an embedded WebView runtime (WKWebView on macOS; Windows/Linux support deprioritized). **Primary target is macOS + Ableton Live.** Communicate via a well-defined IPC (JSON-RPC style) and strictly separate real-time audio thread concerns (lock-free param state and ring buffers) from UI work (runs on main/UI thread). This gives you idiomatic Rust DSP code, a maintainable React codebase, and a focused path to production on the primary platform.  ￼

⸻

## Repository Structure (Monorepo)

Wavecraft is organized as a **monorepo** containing all components of the SDK ecosystem in a single repository. This structure enables coordinated development, atomic commits across components, and simplified dependency management during the SDK's early development phase.

```
wavecraft/
├── cli/                           # CLI tool (cargo install wavecraft)
│   ├── src/                       # CLI source code
│   │   ├── main.rs                # Entry point, clap CLI
│   │   ├── validation.rs          # Crate name validation (syn-based)
│   │   ├── commands/              # Command implementations
│   │   │   ├── mod.rs
│   │   │   └── new.rs             # `wavecraft new` command
│   │   └── template/              # Template extraction & variables
│   │       ├── mod.rs
│   │       └── variables.rs
│   └── sdk-templates/             # Embedded project templates
│       └── new-project/           # `wavecraft new` templates
│           └── react/             # React UI variant (default)
│               ├── Cargo.toml.template
│               ├── engine/        # Rust audio engine template
│               └── ui/            # React UI template
├── docs/                          # Documentation
│   ├── architecture/              # Architecture documents
│   ├── feature-specs/             # Feature specifications
│   └── guides/                    # User guides
├── engine/                        # Rust audio engine & SDK crates
│   ├── crates/                    # SDK crate workspace
│   │   ├── wavecraft-core/        # Core SDK types and macros (publishable)
│   │   ├── wavecraft-nih_plug/    # nih-plug integration layer (git-only)
│   │   ├── wavecraft-macros/      # Procedural macros
│   │   ├── wavecraft-protocol/    # IPC contracts
│   │   ├── wavecraft-bridge/      # IPC handler
│   │   ├── wavecraft-metering/    # Real-time metering
│   │   └── wavecraft-dsp/         # DSP primitives
│   └── xtask/                     # Build automation
├── packaging/                     # AU wrapper, installers
├── scripts/                       # Development scripts
├── ui/                            # React UI (npm workspace)
│   ├── packages/                  # Published npm packages
│   │   ├── core/                  # @wavecraft/core — IPC, hooks, utilities
│   │   └── components/            # @wavecraft/components — React components
│   ├── src/                       # Development app (internal testing)
│   └── test/                      # Test utilities and mocks
```

### Monorepo Benefits

1. **Atomic Changes** — Changes spanning CLI, engine, UI, and template can be made in a single commit, ensuring consistency.

2. **Simplified Development** — Contributors can work on any component without managing multiple repositories.

3. **Template Embedding** — The CLI embeds the plugin template at compile time via `include_dir!`, ensuring the template is always in sync with the CLI version.

4. **Coordinated Releases** — Version bumps and releases are coordinated across all components.

### Component Relationships

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           MONOREPO                                      │
│                                                                         │
│  ┌─────────────────┐     scaffolds      ┌───────────────────────────┐   │
│  │   CLI           │ ──────────────────►│ New Plugin Project        │   │
│  │ (wavecraft new) │                    │ (uses git tag deps)       │   │
│  │                 │                    │                           │   │
│  │  • validation   │                    │ [dependencies]            │   │
│  │  • templates    │                    │ wavecraft-core = {        │   │
│  │  • defaults     │                    │   git = "...wavecraft",  │   │
│  │    (no prompts) │                    │   tag = "wavecraft-cli-  │   │
│  │                 │                    │         v0.7.1" }         │   │
│  └─────────────────┘                    └───────────────────────────┘   │
│                                                     │                   │
│                                          depends on │ (git)             │
│                                                     ▼                   │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                     engine/crates/                              │    │
│  │  ┌─────────────┐  ┌─────────────┐  ┌──────────────────┐         │    │
│  │  │wavecraft-core│  │wavecraft-dsp│  │wavecraft-metering│         │    │
│  │  └─────────────┘  └─────────────┘  └──────────────────┘         │    │
│  │  ┌────────────────┐  ┌────────────────┐  ┌─────────────────┐    │    │
│  │  │wavecraft-macros│  │wavecraft-bridge│  │wavecraft-protocol│   │    │
│  │  └────────────────┘  └────────────────┘  └─────────────────┘    │    │
│  │  ┌─────────────────────────────────────────────────────────┐    │    │
│  │  │ wavecraft-nih_plug (git-only, wraps nih-plug)           │    │    │
│  │  └─────────────────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                    ui/packages/ (npm workspace)                 │    │
│  │  ┌─────────────────────────────┐  ┌────────────────────────┐    │    │
│  │  │ @wavecraft/core (npm)       │  │ @wavecraft/components  │    │    │
│  │  │ • IPC bridge & clients      │  │ (npm)                  │    │    │
│  │  │ • React hooks               │  │ • Meter, Sliders       │    │    │
│  │  │ • Logger, utilities         │  │ • ParameterGroup       │    │    │
│  │  │ • /meters subpath export    │  │ • VersionBadge, etc.   │    │    │
│  │  └─────────────────────────────┘  └────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Phase 1 vs Phase 2 Distribution

| Aspect | Phase 1 (Current) | Phase 2 (Post-1.0) |
|--------|-------------------|---------------------|
| Template location | Embedded in CLI binary | Same (embedded) |
| Rust SDK dependencies | Git tag (`tag = "wavecraft-cli-v0.7.1"`) | Published crates (crates.io) |
| UI SDK dependencies | **npm packages** (`@wavecraft/core`, `@wavecraft/components`) | Same (npm) |
| Development | Rapid iteration | Stable API |
| User workflow | `cargo install wavecraft && wavecraft new` | Same, with crates.io deps |
| CLI behavior | No prompts, uses placeholder defaults | Same |

⸻

## Architecture overview (block diagram, logical)

+---------------------------------------------------------------+
| Plugin binary (single cross-platform project)                 |
|                                                               |
|  +-----------------+    +----------------------+              |
|  | Audio / DSP     |<-->| Plugin API layer     |              |
|  | (Rust, real-    |    | (VST3/AU/CLAP glue)  |              |
|  |  time thread)   |    +----------------------+              |
|  |                 |               ^                       |
|  |  - param atoms  |               | parameter/automation |
|  |  - process()    |               | events                |
|  +-----------------+               v                       |
|                               +----------------+            |
|                               | UI Bridge /    |            |
|  (lock-free queue) <--------> | IPC / messaging | <---+      |
|                               +----------------+     |      |
|                                                      |      |
|  +---------------------------+   +------------------------------+
|  | Embedded WebView (wry /   |   | React SPA (built static)     |
|  | platform-specific)        |   | (HTML/CSS/JS) bundled inside | 
|  | - WKWebView (macOS)       |   |   plugin binary or resources |
|  | - WebView2 (Windows)      |   | - uses host messaging API   |
|  | - WebKitGTK / WRY (Linux) |   +------------------------------+
|  +---------------------------+
+---------------------------------------------------------------+

Key: the audio path never blocks on UI; the UI never directly runs audio code.

⸻

## Main components (concrete)
	1.	Plugin core (Rust)
	•	Use nih-plug (Rust plugin framework) to handle VST3/AU/CLAP exports and common plumbing.  ￼
	•	Implement process() on audio thread; maintain parameter state in atomic types (float atomics) for host automation.
	2.	Plugin API layer
	•	VST3 is supported natively by nih-plug; CLAP is supported natively by nih-plug.
	•	AU is supported via clap-wrapper (converts CLAP → AUv2). nih-plug does not export AU directly.
	•	Ensure build tooling produces all required bundles (VST3/CLAP from Cargo, AU from CMake/clap-wrapper).
	•	Follow Steinberg VST3 dev docs, CLAP spec, and Apple Audio Unit Hosting Guide for format-specific quirks.
	3.	UI (React)
	•	SPA built with Vite + TypeScript + TailwindCSS. Produce static assets (index.html, bundle.js, CSS).
	•	**Styling:** TailwindCSS utility-first approach with custom theme tokens. No component-level CSS files. See [Coding Standards](./coding-standards.md#css--styling-tailwindcss) for details.
	•	Use a small runtime footprint approach: tree-shake, code-split, avoid large libraries unless necessary. CSS bundle target: <10KB gzipped (achieved: ~3.7KB).
	4.	Embedded WebView layer
	•	Use a cross-platform Rust webview binding such as wry (used by Tauri) which wraps native webview engines (WebView2, WKWebView, WebKitGTK). This avoids shipping a full Chromium and keeps the binary smaller than Electron.  ￼
	•	On Windows: WebView2 (Edge/Chromium); macOS: WKWebView; Linux: WebKitGTK or an appropriate system webview.
	•	**Development Environment Note:** Development is focused exclusively on **macOS + Ableton Live**. Windows and Linux support is deprioritized and not actively developed or tested. The architecture supports cross-platform via wry's abstraction, but this is a future consideration, not a current goal.
	5.	IPC / Bridge
	•	**Transport Abstraction**: The IPC layer uses a pluggable transport system:
		- `NativeTransport`: postMessage-based communication in WKWebView (production)
		- `WebSocketTransport`: WebSocket-based communication in browser (development)
	•	**npm Package** (`@wavecraft/core`):
		- IPC: `IpcBridge`, `ParameterClient`, `MeterClient`
		- Hooks: `useParameter`, `useAllParameters`, `useConnectionStatus`, `useMeterFrame`
		- Logging: `logger`, `Logger`, `LogLevel` — structured logging with severity levels
		- Types: `ParameterInfo`, `MeterFrame`, `IpcError`
		- Subpath `/meters`: Pure audio math utilities (`linearToDb`, `dbToLinear`)
	•	JSON-RPC 2.0 message format with request/response correlation. Expose a minimal API:
		- `setParameter(id, value)`
		- `getParameter(id)`
		- `getMeterFrame()`
		- `ping()`
	•	**Connection Management**:
		- Automatic reconnection with exponential backoff (WebSocket mode)
		- Rate-limited disconnect warnings (max 1 per 5s)
		- Connection-aware React hooks via `useConnectionStatus()`
	•	Keep messages small and rate-limited.
	6.	Realtime-safe comms
	•	Use a single-producer single-consumer lock-free ring buffer (SPSC) or atomic double buffer for data from audio → UI (metering, waveform snapshots). Use crates such as rtrb or other proven SPSC ring buffer crates to avoid allocations and locks on the audio thread.  ￼
	7.	Build & Packaging
	•	Rust build (Cargo) for core; CMake or a small shim for packaging VST3 (SDK). Bundle the React build output as plugin resources (embed as bytes or serve them via an in-process file server).
	•	AU builds require macOS; produce `.component` bundles for `/Library/Audio/Plug-Ins/Components/`.
  • Code signing and notarization for macOS via `cargo xtask sign` and `cargo xtask notarize`. The `xtask sign` flow accepts a `SigningConfig` (constructed from env in production via `SigningConfig::from_env()` or built directly for tests via `SigningConfig::new()`).
  • Note: ad-hoc signing is suitable for local testing and CI artifacts; production signing requires Developer ID certificates and notarization via Apple.

⸻

## Versioning

Wavecraft uses semantic versioning (SemVer) with a single source of truth in `engine/Cargo.toml`. The version automatically propagates to plugin metadata and the UI at build time.

### Version Flow

```
┌────────────────────┐
│ engine/Cargo.toml  │  [workspace.package]
│ version = "1.0.0"  │  version = "1.0.0"
└─────────┬──────────┘
          │
          ├──────────────────────────────────────┐
          │                                      │
          ▼                                      ▼
┌─────────────────────┐               ┌─────────────────────┐
│ Plugin Binary       │               │ cargo xtask bundle  │
│ (Rust compile)      │               │ reads Cargo.toml    │
│                     │               │ exports to Vite env │
│ env!("CARGO_PKG_    │               └──────────┬──────────┘
│      VERSION")      │                          │
│         │           │                          ▼
│         ▼           │               ┌─────────────────────┐
│  nih-plug Plugin    │               │ Vite Build          │
│  VERSION constant   │               │ __APP_VERSION__     │
│  → VST3/CLAP        │               │ compile-time const  │
│    metadata         │               └──────────┬──────────┘
└─────────────────────┘                          │
                                                 ▼
                                      ┌─────────────────────┐
                                      │ React UI            │
                                      │ VersionBadge        │
                                      │ displays version    │
                                      └─────────────────────┘
```

### Key Design Decisions

1. **Build-time injection** — Version is embedded at compile time, not fetched via IPC at runtime. This ensures zero runtime cost and no startup latency.

2. **Vite `define` block** — The `__APP_VERSION__` constant is injected via Vite's `define` configuration, which performs compile-time string replacement.

3. **Development fallback** — When building without xtask (e.g., `npm run dev`), the version is read directly from `engine/Cargo.toml` using a regex parser in `vite.config.ts`. This ensures developers always see the correct version during development.

4. **No manual sync** — Changing the version in `Cargo.toml` automatically updates all consumers on next build.

⸻

## Wavecraft SDK Architecture

Wavecraft is designed as a **Developer SDK** that enables other developers to build VST3/CLAP audio plugins with Rust + React. The framework provides core infrastructure while exposing clear extension points for user DSP and UI code.

### SDK Distribution Model

Wavecraft distributes its SDK through two channels:

1. **Rust Crates** — Audio engine, DSP, and plugin framework (via Git tags, crates.io in Phase 2)
2. **npm Packages** — React UI components, IPC hooks, and utilities (via npm)

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                         WAVECRAFT SDK DISTRIBUTION                              │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│   ┌───────────────────────┐       ┌───────────────────────┐                     │
│   │  EMBEDDED TEMPLATE    │       │    GIT-ONLY           │                     │
│   │  cli/sdk-templates/   │       │                       │                     │
│   │  new-project/react/   │       │  wavecraft-nih_plug   │  ← User depends     │
│   │  ├── engine/          │──────▶│  (Cargo rename:       │    (git tag)        │
│   │  │   └── Cargo.toml   │       │   wavecraft = {...})  │                     │
│   │  │   wavecraft = {    │       │                       │                     │
│   │  │     package =      │       └───────────┬───────────┘                     │
│   │  │     "wavecraft-    │                   │                                 │
│   │  │     nih_plug"...}  │                   │ depends on                      │
│   │  │                    │                   ▼                                 │
│   │  │                    │       ┌───────────────────────┐                     │
│   │  │                    │       │    CRATES.IO          │                     │
│   │  │                    │       │                       │                     │
│   │  │                    │       │  wavecraft-core       │  ← Publishable      │
│   │  │                    │       │  wavecraft-dsp        │                     │
│   │  │                    │       │  wavecraft-protocol   │                     │
│   │  │                    │       │  wavecraft-metering   │                     │
│   │  │                    │       │  wavecraft-bridge     │                     │
│   │  │                    │       │  wavecraft-macros     │                     │
│   │  │                    │       └───────────────────────┘                     │
│   │  │                    │                                                     │
│   │  │                    │       ┌───────────────────────┐                     │
│   │  ├── ui/              │       │        NPM            │                     │
│   │  │   └── package.json │──────▶│                       │                     │
│   │  │                    │       │  @wavecraft/core      │  ← UI Framework    │
│   │  └── README.md        │       │  @wavecraft/components│    (user depends)  │
│   └───────────────────────┘       └───────────────────────┘                     │
│              │                                                                  │
│              │  User customizes:                                                │
│              │  - DSP code (Processor trait impl)                               │
│              │  - Parameters (ProcessorParams derive macro)                     │
│              │  - UI components (React, using @wavecraft/components)            │
│              ▼                                                                  │
│   ┌───────────────────────┐                                                     │
│   │   USER'S PLUGIN       │                                                     │
│   │   my-awesome-plugin   │                                                     │
│   └───────────────────────┘                                                     │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### SDK Crate Structure (Rust)

All SDK crates use the `wavecraft-*` naming convention for clear identification:

| Crate | Purpose | Publishable | User Interaction |
|-------|---------|-------------|------------------|
| `wavecraft-nih_plug` | nih-plug integration, WebView editor, plugin exports | ❌ Git only | **Primary dependency** — users import via Cargo rename: `wavecraft = { package = "wavecraft-nih_plug" }` |
| `wavecraft-core` | Core SDK types, declarative macros, no nih_plug dependency | ✅ crates.io | Re-exported via wavecraft-nih_plug |
| `wavecraft-macros` | Procedural macros: `ProcessorParams` derive, `wavecraft_plugin!` proc-macro | ✅ crates.io | Used indirectly via wavecraft-nih_plug |
| `wavecraft-protocol` | IPC contracts, parameter types, JSON-RPC definitions | ✅ crates.io | Implements `ParamSet` trait |
| `wavecraft-bridge` | IPC handler, `ParameterHost` trait for parameter management | ✅ crates.io | Rarely used directly |
| `wavecraft-metering` | Real-time safe SPSC ring buffer for audio → UI metering | ✅ crates.io | Uses `MeterProducer` in DSP |
| `wavecraft-dsp` | DSP primitives, `Processor` trait, built-in processors | ✅ crates.io | Implements `Processor` trait |

> **Why the split?** The `nih_plug` crate cannot be published to crates.io (it has unpublished dependencies). By isolating nih_plug integration in `wavecraft-nih_plug` (git-only), all other crates become publishable. User projects depend on `wavecraft-nih_plug` via git tag, while the ecosystem gains crates.io discoverability for the rest of the SDK.

### npm Package Structure (UI)

The UI SDK is distributed as npm packages, enabling standard JavaScript/TypeScript dependency management:

| Package | Purpose | Exports |
|---------|---------|---------|
| `@wavecraft/core` | IPC bridge, React hooks, utilities, types | `useParameter`, `useAllParameters`, `useMeterFrame`, `IpcBridge`, `Logger`, types |
| `@wavecraft/components` | Pre-built React components | `Meter`, `ParameterSlider`, `ParameterGroup`, `ParameterToggle`, `VersionBadge`, `ConnectionStatus`, `LatencyMonitor`, `ResizeHandle`, `ResizeControls` |

**Subpath Exports:**

The `@wavecraft/core` package supports subpath exports for tree-shaking and avoiding side effects:

```typescript
// Main entry — full SDK (IPC, hooks, utilities)
import { useParameter, IpcBridge, Logger } from '@wavecraft/core';

// Subpath: Pure audio math utilities (no IPC side effects)
import { linearToDb, dbToLinear, getMeterFrame } from '@wavecraft/core/meters';
```

**Package Dependencies:**

```
@wavecraft/components
    └── @wavecraft/core (peer dependency)
            └── react (peer dependency)
```

**User Plugin Usage:**

```typescript
// In user's plugin UI
import { useParameter, useAllParameters, Logger } from '@wavecraft/core';
import { Meter, ParameterSlider, ParameterGroup } from '@wavecraft/components';

function MyPluginUI() {
  const allParams = useAllParameters();
  return (
    <ParameterGroup name="Input">
      {allParams.map(p => <ParameterSlider key={p.id} parameter={p} />)}
    </ParameterGroup>
  );
}
```

### Public API Surface (Rust)

The SDK exposes a minimal, stable API through the `wavecraft::prelude` module (where `wavecraft` is the Cargo rename for `wavecraft-nih_plug`):

```rust
// wavecraft::prelude re-exports (via wavecraft-nih_plug)
pub use nih_plug::prelude::*;  // From wavecraft-nih_plug
pub use wavecraft_dsp::{Processor, ProcessorParams, Transport, builtins};
pub use wavecraft_protocol::{ParamId, ParameterInfo, ParameterType, db_to_linear};
pub use wavecraft_metering::{MeterConsumer, MeterFrame, MeterProducer, create_meter_channel};
#[cfg(any(target_os = "macos", target_os = "windows"))]
pub use crate::editor::WavecraftEditor;
pub use crate::util::calculate_stereo_meters;

// Declarative macros (from wavecraft-core, re-exported)
pub use wavecraft_core::{wavecraft_processor, wavecraft_plugin};
```

> **Note:** The `wavecraft-nih_plug` crate also exports a hidden `__nih` module containing all nih_plug types needed by proc-macro generated code. This allows the `wavecraft_plugin!` macro to reference types like `Plugin`, `Params`, and `FloatParam` through a stable path.

**Key Traits:**

1. **`Processor`** — Core DSP abstraction for audio processing:
   ```rust
   pub trait Processor: Send + 'static {
       type Params: ProcessorParams + Default + Send + Sync + 'static;
       
       fn process(&mut self, buffer: &mut [&mut [f32]], transport: &Transport, params: &Self::Params);
       fn set_sample_rate(&mut self, _sample_rate: f32) {}
       fn reset(&mut self) {}
   }
   ```

2. **`ProcessorParams`** — Parameter metadata for runtime discovery (typically via `#[derive(ProcessorParams)]`):
   ```rust
   pub trait ProcessorParams: Default + Send + Sync + 'static {
       fn param_specs() -> &'static [ParamSpec];
   }
   ```

3. **`ParameterHost`** — Backend trait for parameter management (framework-provided):
   ```rust
   pub trait ParameterHost: Send + Sync {
       fn get_parameters(&self) -> Vec<ParameterInfo>;
       fn get_parameter(&self, id: &str) -> Option<ParameterInfo>;
       fn set_parameter(&self, id: &str, value: f32) -> bool;
   }
   ```

**Macros:**

- **`wavecraft_processor!`** — Creates named wrappers around built-in DSP processors:
  ```rust
  wavecraft_processor!(InputGain => Gain);
  wavecraft_processor!(OutputGain => Gain);
  ```

- **`wavecraft_plugin!`** — Generates complete plugin implementation from minimal DSL:
  ```rust
  wavecraft_plugin! {
      name: "My Plugin",
      vendor: "Wavecraft",
      signal: InputGain,
  }
  ```

- **`#[derive(ProcessorParams)]`** — Auto-generates parameter metadata from struct definition:
  ```rust
  #[derive(ProcessorParams, Default)]
  struct MyParams {
      #[param(range = "-60.0..=24.0", default = 0.0, unit = "dB")]
      gain: f32,
  }
  ```

- **`wavecraft_params!`** — Declarative parameter definition (legacy, prefer derive macro):
  ```rust
  wavecraft_params! {
      Gain: { id: 0, name: "Gain", range: -24.0..=24.0, default: 0.0, unit: "dB" },
      Mix: { id: 1, name: "Mix", range: 0.0..=1.0, default: 1.0, unit: "%" },
  }
  ```

### User Project Structure

The template provides a standardized project structure:

```
my-plugin/
├── engine/
│   ├── Cargo.toml           ← Depends on wavecraft-nih_plug (git tag, Cargo rename)
│   └── src/
│       ├── lib.rs           ← Plugin entry point
│       └── dsp.rs           ← User's Processor implementation
│
├── ui/
│   ├── package.json         ← Depends on @wavecraft/core + @wavecraft/components
│   ├── vite.config.ts
│   └── src/
│       └── App.tsx          ← User's custom UI (imports from npm packages)
│
└── xtask/                   ← Build automation (bundle, dev, etc.)
```

**Template `Cargo.toml` Dependencies:**

```toml
[dependencies]
# Single SDK dependency — Cargo rename gives us `use wavecraft::prelude::*`
wavecraft = { package = "wavecraft-nih_plug", git = "https://github.com/RonHouben/wavecraft", tag = "wavecraft-cli-v0.7.1" }
```

**Template `package.json` Dependencies:**

```json
{
  "dependencies": {
    "@wavecraft/core": "^0.7.0",
    "@wavecraft/components": "^0.7.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  }
}
```

**Template UI Example:**

```tsx
// my-plugin/ui/src/App.tsx
import { useAllParameters, useMeterFrame } from '@wavecraft/core';
import { Meter, ParameterSlider, VersionBadge } from '@wavecraft/components';

export function App() {
  const params = useAllParameters();
  const meters = useMeterFrame();
  
  return (
    <div>
      <VersionBadge />
      <Meter leftDb={meters?.leftDb} rightDb={meters?.rightDb} />
      {params.map(p => <ParameterSlider key={p.id} parameter={p} />)}
    </div>
  );
}
```

### SDK Design Principles

1. **Minimal Boilerplate** — Users implement traits and use macros; framework handles nih-plug integration, WebView setup, and IPC.

2. **Clear Boundaries** — SDK code vs user code is explicit through crate structure and trait contracts.

3. **Composition over Inheritance** — Users compose their plugins from framework components rather than subclassing.

4. **Type Safety** — Compile-time guarantees through Rust's type system; generic `WavecraftEditor<P: Params>` works with any parameter type.

5. **Real-Time Safety by Design** — DSP traits enforce the contract; metering uses proven lock-free patterns.

### Testability & Environment

- Avoid tests that manipulate global state (e.g., environment variables) directly. Code that depends on environment configuration should separate construction from environment reading to make it testable (example: `SigningConfig::new()` + `SigningConfig::from_env()`).
- Tests should prefer dependency injection and pure constructors to remain deterministic and parallelizable; use of test-only serialisation (e.g., `serial_test`) is discouraged as a primary fix for global-state tests.
- The `xtask::sign` commands accept a `SigningConfig` to allow production behavior (`from_env()`) while enabling pure, side-effect-free unit tests via `new()`.

⸻

## Declarative Plugin DSL

Wavecraft provides a declarative domain-specific language (DSL) for defining plugins with minimal boilerplate. The DSL reduces plugin definitions from ~190 lines of manual implementation to ~9 lines.

### DSL Architecture

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          DECLARATIVE PLUGIN DSL                                 │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│   User Code (9 lines)              Generated Code (~400 lines)                  │
│   ────────────────────             ────────────────────────────                 │
│                                                                                 │
│   wavecraft_processor!(            → Plugin struct with metering                │
│       InputGain => Gain            → Default impl with meter channel            │
│   );                               → Plugin trait impl (name, vendor, I/O)      │
│                                    → Params struct via ProcessorParams          │
│   wavecraft_plugin! {              → process() with DSP routing                 │
│       name: "My Plugin",           → VST3Plugin impl (class ID)                 │
│       vendor: "Wavecraft",         → ClapPlugin impl (CLAP ID)                  │
│       signal: InputGain,           → nih_export_vst3!() macro                   │
│   }                                → nih_export_clap!() macro                   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### Macro System

The DSL uses a two-layer macro system:

1. **`wavecraft_processor!`** (declarative macro) — Wraps built-in DSP processors:
   ```rust
   wavecraft_processor!(InputGain => Gain);
   wavecraft_processor!(Bypass => Passthrough);
   ```
   - Creates newtype wrappers around built-in processors
   - Delegates `Processor` trait implementation
   - Maintains type distinction for compile-time safety

2. **`wavecraft_plugin!`** (proc-macro) — Generates complete plugin implementation:
   ```rust
   wavecraft_plugin! {
       name: "My Plugin",
       vendor: "Wavecraft",
       url: "https://example.com",    // optional
       email: "info@example.com",     // optional
       signal: InputGain,
   }
   ```

3. **`#[derive(ProcessorParams)]`** — Auto-generates parameter metadata:
   ```rust
   #[derive(ProcessorParams, Default)]
   struct GainParams {
       #[param(range = "-60.0..=24.0", default = 0.0, unit = "dB", group = "Input")]
       gain: f32,
   }
   ```

### Parameter Runtime Discovery

The DSL supports runtime parameter discovery via the `ProcessorParams` trait:

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                       RUNTIME PARAMETER DISCOVERY                               │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│   #[derive(ProcessorParams)]          ProcessorParams::param_specs()            │
│   struct GainParams {                 ──────────────────────────────►           │
│       #[param(range="...", unit="dB")]    &'static [ParamSpec]                  │
│       gain: f32,                                                                │
│   }                                   ┌──────────────────────────┐              │
│                                       │ ParamSpec {              │              │
│                                       │   name: "Gain",          │              │
│                                       │   id_suffix: "gain",     │              │
│                                       │   range: Linear {...},   │              │
│                                       │   default: 0.0,          │              │
│                                       │   unit: "dB",            │              │
│                                       │   group: Some("Input"),  │              │
│                                       │ }                        │              │
│                                       └──────────────────────────┘              │
│                                                   │                             │
│                                                   ▼                             │
│                                       ┌──────────────────────────┐              │
│                                       │ IPC: getAllParameters    │              │
│                                       │ → ParameterInfo[]        │              │
│                                       │ → React UI renders       │              │
│                                       │   grouped parameters     │              │
│                                       └──────────────────────────┘              │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### UI Parameter Grouping

Parameters can be organized into groups for UI organization:

```typescript
// React hook: useParameterGroups()
const { groupedParams, ungroupedParams } = useParameterGroups();

// Renders ParameterGroup components for each group
// Ungrouped parameters appear in default "Parameters" section
```

The `ParameterGroup` component renders parameters within a named section, improving UI organization for plugins with many parameters.

### Design Decisions

1. **Compile-Time Code Generation** — All boilerplate is generated at compile time, not runtime. This means zero runtime overhead and full IDE support for generated types.

2. **Deterministic VST3 IDs** — The macro generates VST3 class IDs by hashing the plugin name and vendor. This ensures consistent IDs without manual management.

3. **Type-Safe Signal Routing** — The `signal` field accepts any type implementing `Processor`. This enables future composition via `Chain![]` or custom processor types.

4. **Optional Group Field** — The `group` parameter attribute is optional, maintaining backward compatibility while enabling UI organization.

5. **Runtime Discovery over Static Embedding** — Parameters are discovered at runtime via trait methods rather than embedded in static metadata. This simplifies the macro implementation and enables dynamic parameter sets.

### Achieved Code Reduction

| Before (Manual) | After (DSL) | Reduction |
|-----------------|-------------|-----------|
| Plugin struct | Generated | -20 lines |
| Default impl | Generated | -15 lines |
| Plugin trait impl | Generated | -80 lines |
| Params struct | Generated | -40 lines |
| VST3/CLAP impls | Generated | -20 lines |
| Export macros | Generated | -5 lines |
| **Total: ~190 lines** | **~9 lines** | **95%** |

⸻

## Browser Development Mode

Wavecraft supports running the UI in a standard browser for rapid development iteration, with **real engine communication** via WebSocket.

### Development Mode Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       TRANSPORT ABSTRACTION                             │
└─────────────────────────────────────────────────────────────────────────┘

  ┌─────────────────────┐                ┌─────────────────────┐
  │  Browser Dev Mode   │                │  Plugin Mode        │
  │  (npm run dev +     │                │  (Plugin in DAW)    │
  │   cargo xtask dev)  │                │                     │
  └──────────┬──────────┘                └──────────┬──────────┘
             │                                      │
             ▼                                      ▼
  ┌─────────────────────┐                ┌─────────────────────┐
  │ WebSocketTransport  │                │ NativeTransport     │
  │                     │                │                     │
  │ • ws://127.0.0.1:9000               │ • postMessage IPC   │
  │ • Auto-reconnect    │                │ • WKWebView native  │
  │ • Real engine data  │                │ • Synchronous calls │
  └──────────┬──────────┘                └──────────┬──────────┘
             │                                      │
             ▼                                      ▼
  ┌─────────────────────┐                ┌─────────────────────┐
  │ Standalone Dev      │                │ Plugin Binary       │
  │ Server (Rust)       │                │ (Embedded WebView)  │
  │ IpcHandler          │                │ IpcHandler          │
  └─────────────────────┘                └─────────────────────┘
```

### Transport Factory Pattern

The IPC system uses a factory pattern to automatically select the appropriate transport:

```
┌────────────────────────────────────────────────────────────────┐
│                      getTransport()                            │
│                                                                │
│   isWebViewEnvironment() ─────┬───────────────┐                │
│                               │               │                │
│                          (true)          (false)               │
│                               │               │                │
│                               ▼               ▼                │
│                    ┌──────────────┐  ┌───────────────────┐     │
│                    │NativeTransport│  │WebSocketTransport │     │
│                    │              │  │                   │     │
│                    │ postMessage  │  │ ws://127.0.0.1:   │     │
│                    │ __WAVECRAFT_IPC__│  │ 9000              │     │
│                    └──────────────┘  └───────────────────┘     │
└────────────────────────────────────────────────────────────────┘
```

### How It Works

1. **Environment Detection** (`environment.ts`):
   ```typescript
   export function isWebViewEnvironment(): boolean {
     return globalThis.__WAVECRAFT_IPC__ !== undefined;
   }
   ```

2. **Transport Selection** (`transports/index.ts`):
   ```typescript
   // Module-level constant (evaluated once)
   const IS_WEBVIEW = isWebViewEnvironment();
   
   export function getTransport(): Transport {
     if (IS_WEBVIEW) {
       return new NativeTransport();
     } else {
       return new WebSocketTransport({ url: 'ws://127.0.0.1:9000' });
     }
   }
   ```

3. **IpcBridge Abstraction** (`IpcBridge.ts`):
   - Lazy initialization of transport
   - Same API regardless of transport type
   - Rate-limited disconnect warnings (1 per 5s)
   - Graceful degradation when disconnected

4. **WebSocket Features**:
   - Automatic reconnection with exponential backoff (1s, 2s, 4s, 8s, 16s)
   - Maximum 5 reconnection attempts
   - Request timeout (5s) with proper cleanup
   - Connection status monitoring via `useConnectionStatus()` hook

### Development Workflow

```bash
# Start both servers (recommended)
cargo xtask dev

# Or manually:
# Terminal 1: Start WebSocket server
cargo run -p standalone -- --dev-server --port 9000

# Terminal 2: Start Vite dev server
cd ui && npm run dev
```

### Why Module-Level Detection?

The environment constant is evaluated at module scope (not inside hooks) to comply with React's Rules of Hooks. This ensures consistent hook call order across renders.

### Benefits

- **Real engine communication**: Browser UI talks to real Rust backend
- **Hot module reload**: Vite HMR for instant UI updates
- **Same IPC layer**: Identical JSON-RPC protocol as production
- **Robust reconnection**: Automatic recovery from connection drops
- **Graceful degradation**: UI shows "Connecting..." when disconnected

⸻

## Build System & Tooling

Wavecraft uses a Rust-based build system (`xtask`) that provides a unified interface for building, testing, signing, and distributing plugins.


### Available Commands

| Command | Description |
|---------|-------------|
| `cargo xtask check` | **Pre-push validation** — Run lint + tests locally (~52s, 26x faster than Docker CI) |
| `cargo xtask dev` | Start WebSocket + Vite dev servers for browser development |
| `cargo xtask bundle` | Build and bundle VST3/CLAP plugins |
| `cargo xtask test` | Run all tests (Engine + UI) |
| `cargo xtask test --ui` | Run UI tests only (Vitest) |
| `cargo xtask test --engine` | Run Engine tests only (cargo test) |
| `cargo xtask lint` | Run linters for UI and/or engine code |
| `cargo xtask desktop` | Build and run the desktop POC |
| `cargo xtask au` | Build AU wrapper (macOS only) |
| `cargo xtask install` | Install plugins to system directories |
| `cargo xtask clean` | Clean build artifacts |
| `cargo xtask all` | Run full build pipeline (test → bundle → au → install) |
| `cargo xtask sign` | Sign plugin bundles for macOS distribution |
| `cargo xtask notarize` | Notarize plugin bundles with Apple |
| `cargo xtask release` | Complete release workflow (build → sign → notarize) |

### Development Workflow

```bash
# Pre-push validation (recommended before every push)
cargo xtask check            # Run lint + tests (~52s)
cargo xtask check --fix      # Auto-fix linting issues

# Browser-based UI development (recommended for UI work)
cargo xtask dev              # Starts WebSocket server + Vite
cargo xtask dev --verbose    # With detailed IPC logging

# Fast iteration (debug build, no signing)
cargo xtask bundle --debug

# Full build with React UI
cargo xtask bundle

# Build and install for DAW testing
cargo xtask bundle && cargo xtask install

# Build with AU wrapper (macOS)
cargo xtask all
```

### Visual Testing Workflow

Visual testing is done separately from automated checks using the Playwright MCP skill:

```bash
# 1. Start dev servers
cargo xtask dev

# 2. Use Playwright MCP skill for browser-based testing
#    (handled by Tester agent via "playwright-mcp-ui-testing" skill)

# 3. Stop servers when done
pkill -f "cargo xtask dev"
```

### Release Workflow

```bash
# Full release build (requires Apple Developer certificate)
cargo xtask release

# Or step-by-step:
cargo xtask bundle --release
cargo xtask sign
cargo xtask notarize --full
```

### Code Signing (macOS)

Wavecraft plugins require code signing for distribution. The build system provides two signing modes:

**Ad-Hoc Signing** (local development):
```bash
cargo xtask sign --adhoc
```
- No Apple Developer account required
- Plugins work on your local machine only
- Cannot be notarized or distributed

**Developer ID Signing** (distribution):
```bash
export APPLE_SIGNING_IDENTITY="Developer ID Application: Your Name (TEAM_ID)"
cargo xtask sign
```
- Requires Apple Developer Program membership ($99/year)
- Enables notarization and distribution
- Required for plugins to load without Gatekeeper warnings

### Notarization (macOS)

Apple notarization is required for distributed plugins to load on macOS Catalina+.

**Two-Step Workflow** (CI/CD friendly):
```bash
cargo xtask notarize --submit   # Submit and get request ID
# ... wait 5-30 minutes ...
cargo xtask notarize --status   # Check progress
cargo xtask notarize --staple   # Attach ticket when approved
```

**Blocking Workflow** (local development):
```bash
cargo xtask notarize --full     # Submit, wait, and staple
```

### Entitlements

Wavecraft plugins require specific entitlements for the hardened runtime due to WKWebView's JavaScript JIT:

```xml
<!-- engine/signing/entitlements.plist -->
<key>com.apple.security.cs.allow-jit</key>
<true/>
<key>com.apple.security.cs.allow-unsigned-executable-memory</key>
<true/>
<key>com.apple.security.cs.disable-library-validation</key>
<true/>
```

See [macOS Signing Guide](../guides/macos-signing.md) for complete setup instructions.

### CI/CD Pipelines

Wavecraft uses GitHub Actions for continuous integration and release automation.

**CI** (`.github/workflows/ci.yml`):
- Triggers on PRs to `main` (not on merge/push — code already validated via PR)
- Manual trigger available via `workflow_dispatch`
- Validates code quality: linting (ESLint, Prettier, cargo fmt, clippy), documentation links
- Runs automated tests: UI (Vitest) and Engine (cargo test)
- Does NOT build plugin bundles — that's the Release workflow's responsibility

**Template Validation** (`.github/workflows/template-validation.yml`):
- Triggers on PRs to `main` (not on merge/push)
- Manual trigger available via `workflow_dispatch`
- Scaffolds test plugin with CLI and validates compilation

**Continuous Deploy** (`.github/workflows/continuous-deploy.yml`):
- Triggers on push to `main` (after PR merge)
- Detects changed packages and publishes to crates.io/npm

**Release Build** (`.github/workflows/release.yml`):
- Triggers on version tags (`v*`) or manual dispatch
- Imports Developer ID certificate from secrets
- Signs with hardened runtime and entitlements
- Submits for Apple notarization and staples tickets
- Uploads production-ready artifacts

**Required Secrets for Release:**
| Secret | Description |
|--------|-------------|
| `APPLE_CERTIFICATE_P12` | Base64-encoded .p12 certificate |
| `APPLE_CERTIFICATE_PASSWORD` | Password for .p12 file |
| `APPLE_SIGNING_IDENTITY` | Full signing identity string |
| `APPLE_ID` | Apple ID email for notarization |
| `APPLE_TEAM_ID` | 10-character team identifier |
| `APPLE_APP_PASSWORD` | App-specific password for notarytool |

⸻

## Visual Testing

Wavecraft supports browser-based visual testing using Playwright MCP for agent-driven UI validation.

### Architecture

```
  Agent / Developer                 Playwright MCP              Browser
  ┌─────────────┐                  ┌─────────────┐           ┌─────────────┐
  │             │ "take screenshot"│             │   CDP     │             │
  │   Copilot   │─────────────────►│  Playwright │──────────►│  Chromium   │
  │             │                  │  MCP Server │           │  Wavecraft UI  │
  │             │◄─────────────────│             │◄──────────│             │
  └─────────────┘  screenshot.png  └─────────────┘           └──────┬──────┘
        │                                                          │ ws://
        ▼                                                          ▼
  ┌─────────────┐                                           ┌─────────────┐
  │  External   │                                           │    Rust     │
  │  Baselines  │                                           │   Engine    │
  │ ~/.wavecraft/  │                                           │ (xtask dev) │
  └─────────────┘                                           └─────────────┘
```

### Test ID Convention

All UI components have `data-testid` attributes for reliable Playwright selection:

| Component | Test ID Pattern | Example |
|-----------|-----------------|---------|
| App Root | `app-root` | Full page container |
| Meter | `meter-{L\|R}[-{peak\|rms\|db}]` | `meter-L-peak` |
| Parameter | `param-{id}[-{label\|slider\|value}]` | `param-gain-slider` |
| Version | `version-badge` | Version display |
| Connection | `connection-status` | WebSocket status |

### Baseline Storage

Visual baselines are stored externally (not in git) at `~/.wavecraft/visual-baselines/`:
- Keeps repository lean
- Independent versioning from code
- Shareable across development machines

### Key Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Automation tool | Playwright MCP | Agent-native, no custom scripts |
| Baseline location | External (`~/.wavecraft/`) | Repository stays lean |
| Test orchestration | Agent-driven | On-demand, not CI |
| Component targeting | `data-testid` attributes | Stable selectors |

See [Visual Testing Guide](../guides/visual-testing.md) for complete setup and usage instructions.

⸻

## Audio Unit (AU) Architecture

### Overview

Audio Units are Apple's native plugin format, required for Logic Pro and GarageBand compatibility. AU plugins are macOS-only and have distinct architectural requirements from VST3.

> **Important:** nih-plug does **NOT** support AU export directly. The project author has stated that AU support is very low priority due to AUv2's limitations and Apple's uncertain future for the format. See [nih-plug issue #63](https://github.com/robbert-vdh/nih-plug/issues/63) for details.

### AU Support via clap-wrapper

The recommended approach for AU support is to use **[clap-wrapper](https://github.com/free-audio/clap-wrapper/)**, which converts CLAP plugins to AUv2. This is the community-endorsed solution for nih-plug projects needing AU compatibility.

**How it works:**
1. nih-plug exports a `.clap` plugin (fully supported)
2. clap-wrapper (CMake-based) wraps the CLAP binary into an AUv2 `.component` bundle
3. The resulting AU plugin runs in Logic Pro, GarageBand, and other AU hosts

### AU-Specific Requirements

1. **Bundle Structure**
   - AU plugins are packaged as `.component` bundles
   - Install location: `/Library/Audio/Plug-Ins/Components/` (system) or `~/Library/Audio/Plug-Ins/Components/` (user)
   - Bundle must contain `Info.plist` with AU-specific keys (manufacturer code, subtype, type)

2. **Four-Character Codes (4CC)**
   - AU uses 4-character codes for identification:
     - **Manufacturer code**: Unique 4-char identifier (e.g., `'VstK'`)
     - **Subtype code**: Plugin-specific identifier (e.g., `'vsk1'`)
     - **Type code**: `'aufx'` for effects, `'aumu'` for instruments, `'aumf'` for MIDI effects
   - These must be registered with Apple for commercial distribution

3. **Component Registration**
   - macOS caches AU plugins; use `auval` to validate and `killall -9 AudioComponentRegistrar` to refresh cache during development
   - Plugin must pass `auval -v aufx <subtype> <manufacturer>` validation

### clap-wrapper Integration

To convert a nih-plug CLAP plugin to AUv2 using clap-wrapper:

**1. Prerequisites:**
- CMake 3.15+
- Xcode command-line tools (macOS)
- The `.clap` plugin built from nih-plug

**2. CMakeLists.txt Configuration:**

```cmake
cmake_minimum_required(VERSION 3.15)
project(wavecraft) # <-- your project name

# This CMakeLists.txt converts a .clap file into an AUv2 plugin (.component)

# Path to the CLAP plugin built by nih-plug
set(CLAP_PLUGIN_PATH "${CMAKE_CURRENT_SOURCE_DIR}/Wavecraft.clap") # <-- adjust path

# Required for AU SDK on macOS
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_OSX_DEPLOYMENT_TARGET 11.0) # or your minimum target
set(CMAKE_OSX_ARCHITECTURES "arm64;x86_64") # universal binary
enable_language(OBJC)
enable_language(OBJCXX)

# clap-wrapper as submodule (https://github.com/free-audio/clap-wrapper/)
set(CLAP_WRAPPER_DOWNLOAD_DEPENDENCIES ON)
add_subdirectory(clap-wrapper)

# Create AUv2 target
set(AUV2_TARGET ${PROJECT_NAME}_auv2)
add_library(${AUV2_TARGET} MODULE)

# Populate the AUv2 target using clap-wrapper
target_add_auv2_wrapper(
    TARGET ${AUV2_TARGET}
    MACOS_EMBEDDED_CLAP_LOCATION ${CLAP_PLUGIN_PATH}
    
    # AU metadata (must match your plugin)
    OUTPUT_NAME "Wavecraft"
    BUNDLE_IDENTIFIER "com.yourcompany.wavecraft"
    BUNDLE_VERSION "1.0"
    MANUFACTURER_NAME "Your Company"
    MANUFACTURER_CODE "VstK"  # 4-char code
    SUBTYPE_CODE "vsk1"       # 4-char code
    INSTRUMENT_TYPE "aufx"    # aufx=effect, aumu=instrument
)
```

**3. Build Commands:**

```bash
# Build everything (tests → bundle → AU → install)
cd engine
cargo xtask all

# Or step-by-step:
cargo xtask bundle --release    # Build VST3/CLAP
cargo xtask au                  # Build AU wrapper (macOS)
cargo xtask install             # Install to system directories

# Preview what would happen without executing
cargo xtask all --dry-run
```

**4. Important Notes:**
- The `.clap` bundle is embedded inside the `.component` bundle
- Both the inner CLAP and outer AU must be signed for notarization
- Use `cmake --build build --clean-first` if `auval` doesn't detect updates
- Restart the host or run `killall -9 AudioComponentRegistrar` after rebuilds

### Why Not Native AU in nih-plug?

The nih-plug maintainer has explained the rationale ([issue #63](https://github.com/robbert-vdh/nih-plug/issues/63)):

1. **Limited benefit**: AU is only needed for Logic Pro (other DAWs support VST3/CLAP)
2. **API limitations**: AUv2 is older and less flexible than CLAP/VST3
3. **Parameter restrictions**: AU requires linear parameter enumeration with manual tombstones
4. **Uncertain future**: Apple previously deprecated then un-deprecated AUv2
5. **AUv3 issues**: AUv3 has no easy C API and runs in separate processes

The clap-wrapper approach provides AU compatibility without these architectural compromises.

### AU vs VST3 vs CLAP Behavioral Differences

| Aspect | VST3 | AU (via clap-wrapper) | CLAP (native) |
|--------|------|----------------------|---------------|
| Parameter IDs | 32-bit integers | 32-bit integers (AudioUnitParameterID) | String-based IDs |
| Parameter ranges | Arbitrary float | Arbitrary float | Arbitrary float |
| Preset format | `.vstpreset` | `.aupreset` (property list) | Host-dependent |
| State persistence | Binary blob via `IEditController` | Property list via `kAudioUnitProperty_ClassInfo` | Binary blob |
| UI hosting | `IPlugView` interface | `AudioUnitCocoaView` protocol | `clap_plugin_gui` |
| Sidechain | Explicit bus configuration | `kAudioUnitProperty_SupportedChannelLayoutTags` | Audio ports |
| Latency reporting | `IComponent::getLatencySamples()` | `kAudioUnitProperty_Latency` | `clap_plugin_latency` |
| Tail time | `IAudioProcessor::getTailSamples()` | `kAudioUnitProperty_TailTime` | `clap_plugin_tail` |
| nih-plug support | ✅ Native | ⚠️ Via clap-wrapper | ✅ Native |

### AU-Specific Constraints

1. **Threading Model**
   - AU hosts may call render from any thread (not guaranteed to be the same thread)
   - Render callback must be fully reentrant
   - UI updates must dispatch to main thread via GCD

2. **Real-Time Thread Priority**
   - AU render threads run at real-time priority
   - Same real-time safety rules apply: no allocations, no locks, no syscalls

3. **View Lifecycle**
   - Cocoa views must handle `viewDidMoveToWindow` for cleanup
   - WebView embedding requires careful management of `NSView` lifecycle
   - Views may be created/destroyed multiple times during plugin lifetime

### Logic Pro Specific Notes

- Logic Pro has stricter AU validation than other hosts
- Always test with `auval` before Logic Pro testing
- Logic Pro 10.5+ requires notarized plugins on macOS 10.15+
- Logic Pro caches plugin state aggressively; restart Logic after plugin updates

⸻

## Data flows and timing constraints
	•	Control path (host automation): Host ↔ plugin parameter interface (VST parameters). DSP reads parameters atomically on audio thread. UI updates parameters via IPC → plugin parameter setter (which marshals to host param API). Host automation remains authoritative.
	•	Telemetry / metering path: Audio thread writes meter samples into SPSC ring buffer at low frequency (e.g., 30–60 Hz aggregated frames), UI reads from ring buffer on UI thread and renders. Never allocate or block in audio thread.
	•	Large data (waveforms, FFTs): Compute on a worker thread (non-audio) and pass snapshots via ring buffer or shared memory. UI must never request expensive DSP on audio thread.

⸻

## Implementation recommendations (practical steps)
	1.	Prototype (week 0–2)
	•	Small Rust plugin (nih-plug) that exports VST3 and shows a native placeholder GUI. Verify Ableton compatibility.  ￼
	2.	WebView POC (week 2–4)
	•	Create tiny React app and embed it via wry in a minimal Rust app (desktop window) to test IPC and packaging of static assets.
	•	Then replace desktop window with plugin window integration (see next).
	3.	Plugin UI integration (week 4–8)
	•	Integrate webview into plugin GUI code. On macOS use WKWebView, Windows use WebView2 — wry abstracts this.
	•	Implement the IPC bridge; test message roundtrip latencies.
	4.	DSP/UI synchronization
	•	Implement SPSC ring buffer for audio→UI. Precompute and downsample meter data.  ￼
	5.	Polish & Packaging
	•	Bundle static assets, sign binaries, run host compatibility tests (Ableton, Logic, Reaper, etc.).

⸻

## Trade-offs and alternatives
	•	WebView (React) pros
	•	Fast UI iteration, familiar dev tooling, powerful layout/UX.
	•	Cross-platform parity with a single codebase.
	•	WebView cons
	•	Larger binary footprint if you ship a bundled engine; differences between platform web engines can cause rendering/behavioral discrepancies. Tauri/wry uses system webviews to reduce size but inherits engine variation.  ￼
	•	Audio in WebView can be tricky (host audio routing and priorities). There are reported quirks with WebView audio behavior (e.g., how it appears in host). Test carefully.  ￼
	•	Alternative: native GUI in Rust
	•	Using GUI libs (egui/iced/VSTGUI/JUCE) gives tighter host integration and smaller runtime surprises, but you lose React developer ergonomics and need to reimplement complex UIs natively.
	•	Alternative: separate process UI (socket)
	•	Keep plugin small and spawn external UI process (Electron/Tauri). This simplifies UI development but breaks host expectations (single window), and many DAWs do not accept a plugin that spawns a separate UI process nicely; it’s generally discouraged.

⸻

## Real-time safety checklist (musts)
	•	Audio thread: no allocations, no locks, no syscalls that can block.
	•	All audio→UI data goes through preallocated lock-free structures (SPSC ring buffers).
	•	UI→audio control messages update atomic parameter state; heavy work occurs on worker threads.
	•	Limit IPC message rate (coalesce frequent UI control changes to prevent thrashing).
	•	Profiling and testing under high CPU and low buffer sizes (32/64 samples) in Ableton.

References about real-time constraints and ring buffers: best practices and Rust crates (rtrb/direct ring buffer).  ￼

⸻

## Testing matrix (focused on macOS + Ableton)

> **Primary target:** macOS + Ableton Live. Other hosts and platforms are deprioritized.

### Primary (Required)
	•	**Ableton Live (macOS, VST3)** — primary host, must work flawlessly
	•	Buffer/CPU tests: low buffer sizes (32/64) and high CPU stress to detect audio dropouts
	•	Automation tests: host automation read/write roundtrip verified
	•	UI tests: verify parameter updates from host appear in UI and UI changes are streamed back to host automation

### Secondary (Nice-to-Have)
	•	Logic Pro (macOS, AU) — requires AU via clap-wrapper
	•	GarageBand (macOS, AU)
	•	AU validation: `auval -v aufx <subtype> <manufacturer>` must pass with no errors
	•	AU-specific tests: load in AU Lab, state save/restore, bypass state

### Deprioritized (Future Consideration)
	•	Ableton Live (Windows)
	•	Reaper (all platforms)
	•	Cubase, FL Studio
	•	Linux hosts
	•	Platform checklists for Windows (WebView2) and Linux (WebKitGTK)

⸻

## Packaging & distribution notes
	•	macOS: notarization and signing required; package VST3 (`.vst3`), CLAP (`.clap`), and AU (`.component` via clap-wrapper); embed React assets into plugin bundle resources.
		- VST3: `/Library/Audio/Plug-Ins/VST3/Wavecraft.vst3`
		- CLAP: `/Library/Audio/Plug-Ins/CLAP/Wavecraft.clap`
		- AU: `/Library/Audio/Plug-Ins/Components/Wavecraft.component` (built via clap-wrapper from CLAP)
		- AU requires valid `Info.plist` with `AudioComponents` array (clap-wrapper generates this)
		- **Signing**: `cargo xtask sign` (or `--adhoc` for local dev)
		- **Notarization**: `cargo xtask notarize --full` (requires Apple Developer account)
		- **Release workflow**: `cargo xtask release` (bundle → sign → notarize)
	•	Windows: ensure WebView2 runtime installed or include evergreen bootstrap in installer; produce .dll VST3 and installer (MSI). AU not applicable. Signing is deprioritized.
	•	Linux: many host distros vary; recommend shipping CLAP/VST3 and provide AppImage/Flatpak for GUI testing. AU not applicable. Deprioritized.

Docs for VST3 build process: Steinberg dev portal.  ￼

⸻

## Risks & mitigations
	1.	WebView audio / host integration quirks
	•	Risk: audio inside WebView might not behave as expected or may be routed differently.
	•	Mitigation: do host tests early; consider disabling in-webview audio entirely (avoiding audio playback inside the UI).
	2.	Cross-engine rendering differences
	•	Risk: CSS/JS behaves slightly differently across WebKit vs Chromium.
	•	Mitigation: constrain to common subset of web APIs; automated visual tests per platform. See [Visual Testing Guide](../guides/visual-testing.md) for Playwright-based screenshot comparison.
	3.	Binary size / dependency issues
	•	Risk: shipping a large engine increases installer size.
	•	Mitigation: use system webviews (wry/tauri approach) to avoid bundling Chromium; selectively polyfill features.
	4.	Real-time safety mistakes
	•	Risk: accidental allocations or locks in process() cause xruns.
	•	Mitigation: code reviews, linters, try to run audio thread with sanitizers and stress tests; prefer proven patterns (preallocated buffers, atomics, SPSC ring buffers).  ￼
	5.	AU validation failures
	•	Risk: Plugin fails `auval` or behaves incorrectly in Logic Pro.
	•	Mitigation: run `auval` in CI pipeline; test state save/restore; ensure parameter ranges and metadata are consistent between formats.
	6.	AU cache invalidation during development
	•	Risk: macOS caches AU plugins; changes not reflected in hosts.
	•	Mitigation: Use `killall -9 AudioComponentRegistrar` and restart host after rebuilds; consider incrementing version during development.
	7.	Code signing and notarization failures
	•	Risk: Plugin fails to load due to Gatekeeper or hardened runtime issues.
	•	Mitigation: Use proper entitlements for WKWebView JIT (`allow-jit`, `allow-unsigned-executable-memory`); test on fresh macOS installs; use `cargo xtask sign --adhoc` during development to catch entitlement issues early.

⸻

## Recommended libraries & tools (quick list)
	•	Audio / plugin: nih-plug (Rust).  ￼
	•	Platform webview: wry (Rust) / system WebView2 / WKWebView / WebKitGTK.  ￼
	•	Real-time buffers: rtrb or direct_ring_buffer crates (SPSC).  ￼
	•	Build: Cargo + CMake (for AU wrapper) + xtask (custom build commands).
	•	Signing: `codesign` (macOS) via `cargo xtask sign`.
	•	Notarization: `notarytool` (macOS) via `cargo xtask notarize`.
	•	React tooling: Vite + TypeScript + TailwindCSS, bundle to static assets.

⸻

## Minimal interface contract (example)

Define JSON messages exchanged over the webview bridge. Keep it small and versioned.
	•	From UI → Host
```json
{ "type": "setParameter", "paramId": "gain", "value": 0.73 }
```

	•	From Host → UI
```json
{ "type": "paramUpdate", "paramId": "gain", "value": 0.73 }
```

	•	Meter frame (audio → UI, via ring buffer snapshot)
```json
{ "type": "meterFrame", "meters": [{ "id":"outL", "peak":0.7, "rms":0.12 }, ...], "ts": 1680000000 }
```

Version each message payload so UI and plugin can be backward compatible.

⸻

## Roadmap

See [Roadmap](../roadmap.md) for detailed milestones and implementation progress.

⸻

## Appendix — Key references
	•	nih-plug (Rust plugin framework).  ￼
	•	Steinberg VST3 SDK & developer tutorials.  ￼
	•	Wry / Tauri webview (cross-platform Rust webview).  ￼
	•	WebView2 overview & APIs (Windows).  ￼
	•	Real-time safe ring buffer crates and patterns (rtrb, direct ring buffers).  ￼
