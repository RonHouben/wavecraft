# High-Level Design — React UI for a Rust VST Plugin

⸻

## Related Documents

- [Coding Standards](./coding-standards.md) — Conventions for TypeScript, Rust, and React code
- [Agent Development Flow](./agent-development-flow.md) — Agent roles and handoffs
- [Roadmap](../roadmap.md) — Project milestones and implementation plan
- [macOS Signing Guide](../guides/macos-signing.md) — Code signing and notarization setup
- [Visual Testing Guide](../guides/visual-testing.md) — Browser-based visual testing with Playwright
- [SDK Getting Started](../guides/sdk-getting-started.md) — Building plugins with Wavecraft SDK
- [SDK Architecture](./sdk-architecture.md) — SDK distribution, crate structure, npm packages
- [Declarative Plugin DSL](./declarative-plugin-dsl.md) — Macro system and parameter discovery
- [Development Workflows](./development-workflows.md) — Browser dev mode, build system, CI/CD
- [Plugin Formats](./plugin-formats.md) — VST3, CLAP, AU architecture
- [Versioning and Distribution](./versioning-and-distribution.md) — Version flow, packaging, signing

⸻

## Assumptions (explicit)

    •	**Primary target:** macOS + Ableton Live (VST3). Windows and Linux are deprioritized.
    •	Audio engine / DSP will be implemented in Rust.
    •	UI must be built in React (single-page app, built with Vite/webpack/etc) and embedded inside the plugin UI window (not a separate app).
    •	Plugin formats to support: VST3 (primary via nih-plug), CLAP (secondary via nih-plug), AU (nice-to-have via clap-wrapper for Logic Pro).
    •	No Electron or Tauri; prefer a lightweight embedded webview or an equivalent approach.
    •	Focus on production-ready macOS support first; cross-platform is a future consideration.

> **Note on AU support:** nih-plug does not export AU directly. AU plugins are generated by wrapping the CLAP output using [clap-wrapper](https://github.com/free-audio/clap-wrapper/). This is the community-recommended approach. See the "Audio Unit (AU) Architecture" section for details.

⸻

## Executive summary (one paragraph)

Build the audio/DSP core and host/plugin API surface in Rust (use a modern Rust plugin framework such as nih-plug), expose a minimal parameter and event API, and embed a React frontend by bundling the built static assets into an embedded WebView runtime (WKWebView on macOS; Windows/Linux support deprioritized). **Primary target is macOS + Ableton Live.** Communicate via a well-defined IPC (JSON-RPC style) and strictly separate real-time audio thread concerns (lock-free param state and ring buffers) from UI work (runs on main/UI thread). This gives you idiomatic Rust DSP code, a maintainable React codebase, and a focused path to production on the primary platform. ￼

⸻

## Repository Structure (Monorepo)

Wavecraft is organized as a **monorepo** containing all components of the SDK ecosystem in a single repository. This structure enables coordinated development, atomic commits across components, and simplified dependency management during the SDK's early development phase.

```
wavecraft/
├── cli/                           # CLI tool (cargo install wavecraft)
│   ├── build.rs                   # Build-time staging: filters sdk-template/ for include_dir!
│   ├── src/                       # CLI source code
│   │   ├── main.rs                # Entry point, clap CLI
│   │   ├── validation.rs          # Crate name validation (syn-based)
│   │   ├── sdk_detect.rs          # Auto-detect SDK dev mode (cargo run vs install)
│   │   ├── commands/              # Command implementations
│   │   │   ├── mod.rs
│   │   │   ├── create.rs          # `wavecraft create` command
│   │   │   ├── start.rs           # `wavecraft start` dev servers
│   │   │   └── update.rs          # `wavecraft update` CLI self-update + dependency updates
│   │   └── template/              # Template extraction & variables
│   │       ├── mod.rs
│   │       └── variables.rs
├── sdk-template/                  # Single source of truth for plugin scaffold (embedded by CLI at build time)
│   ├── Cargo.toml.template
│   ├── engine/                    # Rust audio engine template
│   └── ui/                        # React UI template
├── dev-server/                    # Unified dev server (standalone crate)
│   ├── Cargo.toml                 # Not in engine workspace
│   └── src/                       # Dev server source
│       ├── ws/                    # WebSocket server
│       ├── audio/                 # Audio I/O (feature-gated)
│       ├── reload/                # Hot-reload & file watching
│       ├── host.rs                # DevServerHost implementation
│       └── session.rs             # Session management
├── docs/                          # Documentation
│   ├── architecture/              # Architecture documents
│   ├── feature-specs/             # Feature specifications
│   └── guides/                    # User guides
├── engine/                        # Rust audio engine & SDK crates
│   ├── crates/                    # SDK crate workspace
│   │   ├── wavecraft-core/        # Core SDK types and macros (publishable)
│   │   ├── wavecraft-nih_plug/    # nih-plug integration layer (git-only)
│   │   ├── wavecraft-macros/      # Procedural macros
│   │   ├── wavecraft-protocol/    # IPC contracts
│   │   ├── wavecraft-bridge/      # IPC handler
│   │   ├── wavecraft-metering/    # Real-time metering
│   │   ├── wavecraft-dsp/         # DSP primitives
│   │   └── ...                    # Additional SDK crates
│   └── xtask/                     # Build automation
├── packaging/                     # AU wrapper, installers
├── scripts/                       # Development scripts
├── ui/                            # React UI package workspace (npm packages only — no app code)
│   ├── packages/                  # Published npm packages
│   │   ├── core/                  # @wavecraft/core — IPC, hooks, utilities
│   │   └── components/            # @wavecraft/components — React components
│   └── test/                      # Shared test utilities and mocks
```

### Monorepo Benefits

1. **Atomic Changes** — Changes spanning CLI, engine, UI, and template can be made in a single commit, ensuring consistency.

2. **Simplified Development** — Contributors can work on any component without managing multiple repositories.

3. **Template Embedding** — The CLI embeds the plugin template at compile time via `include_dir!`. A build-time staging step (`cli/build.rs`) copies `sdk-template/` to a clean directory, excluding `target/`, `node_modules/`, and `dist/`, ensuring the embedded template is always in sync and free of build artifacts.

4. **Coordinated Releases** — Version bumps and releases are coordinated across all components.

### Component Relationships

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           MONOREPO                                      │
│                                                                         │
│  ┌─────────────────┐     scaffolds      ┌───────────────────────────┐   │
│  │   CLI           │ ──────────────────►│ New Plugin Project        │   │
│  │(wavecraft create)│                    │ (git tag or path deps)    │   │
│  │                 │                    │                           │   │
│  │  • validation   │                    │ [dependencies]            │   │
│  │  • templates    │                    │ wavecraft-core = {        │   │
│  │  • sdk_detect   │                    │   git = "...wavecraft",  │   │
│  │  • defaults     │                    │   tag = "wavecraft-cli-  │   │
│  │    (no prompts) │          ┌─────────│         v0.7.1" }         │   │
│  └────┬────────────┘          │         └───────────────────────────┘   │
│       │                       │                    │                   │
│       │ depends on            │         depends on │ (git)             │
│       │ (default-features=false)         ▼                   │
│       ▼                       │         ┌───────────────────────────┐   │
│  ┌──────────────────────────────────┐   │    engine/crates/         │   │
│  │  dev-server/ (standalone crate)  │   │                           │   │
│  │  • WebSocket server              │───┤  ┌─────────────┐          │   │
│  │  • Audio I/O (feature-gated)     │   │  │wavecraft-   │          │   │
│  │  • Hot-reload                    │   │  │protocol     │          │   │
│  │  • RebuildCallbacks              │   │  └─────────────┘          │   │
│  │    depends on ──────────────────────►│  ┌─────────────┐          │   │
│  │    wavecraft-bridge              │   │  │wavecraft-   │          │   │
│  │    wavecraft-protocol            │   │  │bridge       │          │   │
│  └──────────────────────────────────┘   │  └─────────────┘          │   │
│                                          │  ┌────────────────────┐   │   │
│                                          │  │wavecraft-core      │   │   │
│                                          │  │wavecraft-dsp       │   │   │
│                                          │  │wavecraft-metering  │   │   │
│                                          │  │wavecraft-macros    │   │   │
│                                          │  │wavecraft-nih_plug  │   │   │
│                                          │  │  (git-only)        │   │   │
│                                          │  └────────────────────┘   │   │
│                                          └───────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                    ui/packages/ (npm workspace)                 │    │
│  │  ┌─────────────────────────────┐  ┌────────────────────────┐    │    │
│  │  │ @wavecraft/core (npm)       │  │ @wavecraft/components  │    │    │
│  │  │ • IPC bridge & clients      │  │ (npm)                  │    │    │
│  │  │ • React hooks               │  │ • Meter, Sliders       │    │    │
│  │  │ • Logger, utilities         │  │ • ParameterGroup       │    │    │
│  │  │ • /meters subpath export    │  │ • VersionBadge, etc.   │    │    │
│  │  └─────────────────────────────┘  └────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Phase 1 vs Phase 2 Distribution

| Aspect                | Phase 1 (Current)                                              | Phase 2 (Post-1.0)           |
| --------------------- | -------------------------------------------------------------- | ---------------------------- |
| Template location     | Embedded in CLI binary                                         | Same (embedded)              |
| Rust SDK dependencies | Git tag (`tag = "wavecraft-cli-v0.7.1"`)                       | Published crates (crates.io) |
| UI SDK dependencies   | **npm packages** (`@wavecraft/core`, `@wavecraft/components`)  | Same (npm)                   |
| Development           | Rapid iteration                                                | Stable API                   |
| User workflow         | `cargo install wavecraft && wavecraft create`                  | Same, with crates.io deps    |
| CLI updates           | `wavecraft update` (self-updates CLI first, then project deps) | Same                         |
| CLI behavior          | No prompts, uses placeholder defaults                          | Same                         |
| SDK dev mode          | Auto-detected via `cargo run` (path deps)                      | Same                         |

⸻

## Architecture overview (block diagram, logical)

+---------------------------------------------------------------+
| Plugin binary (single cross-platform project) |
| |
| +-----------------+ +----------------------+ |
| | Audio / DSP |<-->| Plugin API layer | |
| | (Rust, real- | | (VST3/AU/CLAP glue) | |
| | time thread) | +----------------------+ |
| | | ^ |
| | - param atoms | | parameter/automation |
| | - process() | | events |
| +-----------------+ v |
| +----------------+ |
| | UI Bridge / | |
| (lock-free queue) <--------> | IPC / messaging | <---+ |
| +----------------+ | |
| | |
| +---------------------------+ +------------------------------+
| | Embedded WebView (wry / | | React SPA (built static) |
| | platform-specific) | | (HTML/CSS/JS) bundled inside |
| | - WKWebView (macOS) | | plugin binary or resources |
| | - WebView2 (Windows) | | - uses host messaging API |
| | - WebKitGTK / WRY (Linux) | +------------------------------+
| +---------------------------+
+---------------------------------------------------------------+

Key: the audio path never blocks on UI; the UI never directly runs audio code.

⸻

## Main components (concrete)

    1.	Plugin core (Rust)
    •	Use nih-plug (Rust plugin framework) to handle VST3/AU/CLAP exports and common plumbing.  ￼
    •	Implement process() on audio thread; maintain parameter state in atomic types (float atomics) for host automation.
    2.	Plugin API layer
    •	VST3 is supported natively by nih-plug; CLAP is supported natively by nih-plug.
    •	AU is supported via clap-wrapper (converts CLAP → AUv2). nih-plug does not export AU directly.
    •	Ensure build tooling produces all required bundles (VST3/CLAP from Cargo, AU from CMake/clap-wrapper).
    •	Follow Steinberg VST3 dev docs, CLAP spec, and Apple Audio Unit Hosting Guide for format-specific quirks.
    3.	UI (React)
    •	SPA built with Vite + TypeScript + TailwindCSS. Produce static assets (index.html, bundle.js, CSS).
    •	**Styling:** TailwindCSS utility-first approach with custom theme tokens. No component-level CSS files. See [CSS Standards](./coding-standards-css.md) for details.
    •	Use a small runtime footprint approach: tree-shake, code-split, avoid large libraries unless necessary. CSS bundle target: <10KB gzipped (achieved: ~3.7KB).
    4.	Embedded WebView layer
    •	Use a cross-platform Rust webview binding such as wry (used by Tauri) which wraps native webview engines (WebView2, WKWebView, WebKitGTK). This avoids shipping a full Chromium and keeps the binary smaller than Electron.  ￼
    •	On Windows: WebView2 (Edge/Chromium); macOS: WKWebView; Linux: WebKitGTK or an appropriate system webview.
    •	**Development Environment Note:** Development is focused exclusively on **macOS + Ableton Live**. Windows and Linux support is deprioritized and not actively developed or tested. The architecture supports cross-platform via wry's abstraction, but this is a future consideration, not a current goal.
    5.	IPC / Bridge
    •	**Transport Abstraction**: The IPC layer uses a pluggable transport system:
    	- `NativeTransport`: postMessage-based communication in WKWebView (production)
    	- `WebSocketTransport`: WebSocket-based communication in browser (development)
    •	**npm Package** (`@wavecraft/core`):
    	- IPC: `IpcBridge`, `ParameterClient`, `MeterClient`
    	- Hooks: `useParameter`, `useAllParameters`, `useConnectionStatus`, `useMeterFrame`
    	- Logging: `logger`, `Logger`, `LogLevel` — structured logging with severity levels
    	- Types: `ParameterInfo`, `ParameterId`, `ParameterIdMap`, `MeterFrame`, `IpcError`
    	- Subpath `/meters`: Pure audio math utilities (`linearToDb`, `dbToLinear`)
    •	JSON-RPC 2.0 message format with request/response correlation. Expose a minimal API:
    	- `setParameter(id, value)`
    	- `getParameter(id)`
    	- `getMeterFrame()`
    	- `ping()`
    •	**Connection Management**:
    	- Automatic reconnection with exponential backoff (WebSocket mode)
    	- Rate-limited disconnect warnings (max 1 per 5s)
    	- Connection-aware React hooks via `useConnectionStatus()`
    •	Keep messages small and rate-limited.
    6.	Realtime-safe comms
    •	Use a single-producer single-consumer lock-free ring buffer (SPSC) or atomic double buffer for data from audio → UI (metering, waveform snapshots). Use crates such as rtrb or other proven SPSC ring buffer crates to avoid allocations and locks on the audio thread.  ￼
    7.	Build & Packaging
    •	Rust build (Cargo) for core; CMake or a small shim for packaging VST3 (SDK). Bundle the React build output as plugin resources (embed as bytes or serve them via an in-process file server).
    •	**Two-Stage UI Build:** The npm packages (`@wavecraft/core`, `@wavecraft/components`) are built first via `npm run build:lib` in `ui/`. Then the full app is built in `sdk-template/ui/` (which imports those packages). The resulting `sdk-template/ui/dist/` is copied to `ui/dist/` for engine embedding via `include_dir!`.
    •	**TypeScript Codegen:** `wavecraft start` extracts parameter IDs from the compiled Rust engine via FFI and generates `ui/src/generated/parameters.ts` — a module augmentation file that types the `ParameterId` union in `@wavecraft/core`. This file is regenerated automatically on Rust source changes during development. It is a build artifact (gitignored), not checked into source control.
    •	AU builds require macOS; produce `.component` bundles for `/Library/Audio/Plug-Ins/Components/`.

• Code signing and notarization for macOS via `cargo xtask sign` and `cargo xtask notarize`. The `xtask sign` flow accepts a `SigningConfig` (constructed from env in production via `SigningConfig::from_env()` or built directly for tests via `SigningConfig::new()`).
• Note: ad-hoc signing is suitable for local testing and CI artifacts; production signing requires Developer ID certificates and notarization via Apple.

---

## Documentation Structure

For detailed coverage of specific topics, see:

| Document                                                        | Scope                                                            |
| --------------------------------------------------------------- | ---------------------------------------------------------------- |
| [SDK Architecture](./sdk-architecture.md)                       | Crate structure, npm packages, public API, distribution model    |
| [Declarative Plugin DSL](./declarative-plugin-dsl.md)           | Macro system, parameter discovery, DSL limitations               |
| [Development Workflows](./development-workflows.md)             | Browser dev mode, FFI audio, build system, CI/CD, visual testing |
| [Plugin Formats](./plugin-formats.md)                           | VST3, CLAP, AU architecture, host compatibility, testing matrix  |
| [Versioning and Distribution](./versioning-and-distribution.md) | Version flow, build-time injection, packaging, signing           |

For coding conventions, see:

| Document                                               | Scope                                           |
| ------------------------------------------------------ | ----------------------------------------------- |
| [Coding Standards](./coding-standards.md)              | Overview hub, naming conventions, general rules |
| [TypeScript & React](./coding-standards-typescript.md) | Classes, hooks, React components, imports       |
| [CSS & Styling](./coding-standards-css.md)             | TailwindCSS, theme tokens, WebView styling      |
| [Rust](./coding-standards-rust.md)                     | Module org, real-time safety, FFI, xtask        |
| [Testing & Quality](./coding-standards-testing.md)     | Testing, linting, logging, error handling       |

## Data flows and timing constraints

    •	Control path (host automation): Host ↔ plugin parameter interface (VST parameters). DSP reads parameters atomically on audio thread. UI updates parameters via IPC → plugin parameter setter (which marshals to host param API). Host automation remains authoritative.
    •	Telemetry / metering path: Audio thread writes meter samples into SPSC ring buffer at low frequency (e.g., 30–60 Hz aggregated frames), UI reads from ring buffer on UI thread and renders. Never allocate or block in audio thread.
    •	Large data (waveforms, FFTs): Compute on a worker thread (non-audio) and pass snapshots via ring buffer or shared memory. UI must never request expensive DSP on audio thread.

⸻

## Implementation recommendations (practical steps)

    1.	Prototype (week 0–2)
    •	Small Rust plugin (nih-plug) that exports VST3 and shows a native placeholder GUI. Verify Ableton compatibility.  ￼
    2.	WebView POC (week 2–4)
    •	Create tiny React app and embed it via wry in a minimal Rust app (desktop window) to test IPC and packaging of static assets.
    •	Then replace desktop window with plugin window integration (see next).
    3.	Plugin UI integration (week 4–8)
    •	Integrate webview into plugin GUI code. On macOS use WKWebView, Windows use WebView2 — wry abstracts this.
    •	Implement the IPC bridge; test message roundtrip latencies.
    4.	DSP/UI synchronization
    •	Implement SPSC ring buffer for audio→UI. Precompute and downsample meter data.  ￼
    5.	Polish & Packaging
    •	Bundle static assets, sign binaries, run host compatibility tests (Ableton, Logic, Reaper, etc.).

⸻

## Trade-offs and alternatives

    •	WebView (React) pros
    •	Fast UI iteration, familiar dev tooling, powerful layout/UX.
    •	Cross-platform parity with a single codebase.
    •	WebView cons
    •	Larger binary footprint if you ship a bundled engine; differences between platform web engines can cause rendering/behavioral discrepancies. Tauri/wry uses system webviews to reduce size but inherits engine variation.  ￼
    •	Audio in WebView can be tricky (host audio routing and priorities). There are reported quirks with WebView audio behavior (e.g., how it appears in host). Test carefully.  ￼
    •	Alternative: native GUI in Rust
    •	Using GUI libs (egui/iced/VSTGUI/JUCE) gives tighter host integration and smaller runtime surprises, but you lose React developer ergonomics and need to reimplement complex UIs natively.
    •	Alternative: separate process UI (socket)
    •	Keep plugin small and spawn external UI process (Electron/Tauri). This simplifies UI development but breaks host expectations (single window), and many DAWs do not accept a plugin that spawns a separate UI process nicely; it’s generally discouraged.

⸻

## Real-time safety checklist (musts)

    •	Audio thread: no allocations, no locks, no syscalls that can block.
    •	All audio→UI data goes through preallocated lock-free structures (SPSC ring buffers).
    •	UI→audio control messages update atomic parameter state; heavy work occurs on worker threads.
    •	Limit IPC message rate (coalesce frequent UI control changes to prevent thrashing).
    •	Profiling and testing under high CPU and low buffer sizes (32/64 samples) in Ableton.

References about real-time constraints and ring buffers: best practices and Rust crates (rtrb/direct ring buffer). ￼

⸻

## Risks & mitigations

    1.	WebView audio / host integration quirks
    •	Risk: audio inside WebView might not behave as expected or may be routed differently.
    •	Mitigation: do host tests early; consider disabling in-webview audio entirely (avoiding audio playback inside the UI).
    2.	Cross-engine rendering differences
    •	Risk: CSS/JS behaves slightly differently across WebKit vs Chromium.
    •	Mitigation: constrain to common subset of web APIs; automated visual tests per platform. See [Visual Testing Guide](../guides/visual-testing.md) for Playwright-based screenshot comparison.
    3.	Binary size / dependency issues
    •	Risk: shipping a large engine increases installer size.
    •	Mitigation: use system webviews (wry/tauri approach) to avoid bundling Chromium; selectively polyfill features.
    4.	Real-time safety mistakes
    •	Risk: accidental allocations or locks in process() cause xruns.
    •	Mitigation: code reviews, linters, try to run audio thread with sanitizers and stress tests; prefer proven patterns (preallocated buffers, atomics, SPSC ring buffers).  ￼
    5.	AU validation failures
    •	Risk: Plugin fails `auval` or behaves incorrectly in Logic Pro.
    •	Mitigation: run `auval` in CI pipeline; test state save/restore; ensure parameter ranges and metadata are consistent between formats.
    6.	AU cache invalidation during development
    •	Risk: macOS caches AU plugins; changes not reflected in hosts.
    •	Mitigation: Use `killall -9 AudioComponentRegistrar` and restart host after rebuilds; consider incrementing version during development.
    7.	Code signing and notarization failures
    •	Risk: Plugin fails to load due to Gatekeeper or hardened runtime issues.
    •	Mitigation: Use proper entitlements for WKWebView JIT (`allow-jit`, `allow-unsigned-executable-memory`); test on fresh macOS installs; use `cargo xtask sign --adhoc` during development to catch entitlement issues early.

⸻

## Recommended libraries & tools (quick list)

    •	Audio / plugin: nih-plug (Rust).  ￼
    •	Platform webview: wry (Rust) / system WebView2 / WKWebView / WebKitGTK.  ￼
    •	Real-time buffers: rtrb or direct_ring_buffer crates (SPSC).  ￼
    •	Build: Cargo + CMake (for AU wrapper) + xtask (custom build commands).
    •	Signing: `codesign` (macOS) via `cargo xtask sign`.
    •	Notarization: `notarytool` (macOS) via `cargo xtask notarize`.
    •	React tooling: Vite + TypeScript + TailwindCSS, bundle to static assets.

⸻

## Minimal interface contract (example)

Define JSON messages exchanged over the webview bridge. Keep it small and versioned.
• From UI → Host

```json
{ "type": "setParameter", "paramId": "gain", "value": 0.73 }
```

    •	From Host → UI

```json
{ "type": "paramUpdate", "paramId": "gain", "value": 0.73 }
```

    •	Meter frame (audio → UI, via ring buffer snapshot)

```json
{ "type": "meterFrame", "meters": [{ "id":"outL", "peak":0.7, "rms":0.12 }, ...], "ts": 1680000000 }
```

Version each message payload so UI and plugin can be backward compatible.

⸻

## Roadmap

See [Roadmap](../roadmap.md) for detailed milestones and implementation progress.

⸻

## Appendix — Key references

    •	nih-plug (Rust plugin framework).  ￼
    •	Steinberg VST3 SDK & developer tutorials.  ￼
    •	Wry / Tauri webview (cross-platform Rust webview).  ￼
    •	WebView2 overview & APIs (Windows).  ￼
    •	Real-time safe ring buffer crates and patterns (rtrb, direct ring buffers).  ￼
